<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[beace lee的博客]]></title>
  <link href="beace.github.io/atom.xml" rel="self"/>
  <link href="beace.github.io/"/>
  <updated>2017-04-18T15:23:20+08:00</updated>
  <id>beace.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[HTML5 dataset 属性不为人知的地方（命名规则和原理）]]></title>
    <link href="beace.github.io/HTML5%20dataset.html"/>
    <updated>2017-04-18T14:06:51+08:00</updated>
    <id>beace.github.io/HTML5%20dataset.html</id>
    <content type="html"><![CDATA[
<p><em>HTML5</em>在元素中增加了<em>data-*</em>，可以允许用户自定义属性。这种可读写的方式极大的方便了<br/>
操作元素时的数据存储、状态保留。经常可以在各大主流网站上面看到它的使用，例如淘宝首页。</p>

<p><img src="media/14924956119427/14924960637439.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<p>下面记录下一些使用细节。</p>

<h2 id="toc_0">语法</h2>

<p>在语法上，我们可以在任何DOM元素上添加该属性，但是需要遵照一些命名规则。</p>

<h3 id="toc_1">命名规则</h3>

<ul>
<li>必须使用<em>data-</em>最为前缀，<em>data-</em>后面数据类型允许<em>字符串</em>，<em>数字</em>，<em>-</em>，<em>.</em>，<em>:</em>，<em>_</em> 。当然了，在使用JavaScript获取时就不能单纯地将一些特殊字符直接点属性使用了。</li>
</ul>

<p><img src="media/14924956119427/14924965473433.jpg" alt=""/></p>

<ul>
<li>不可以使用大写字母。这里说不可以是不太准确的，建议可能更加恰当。但是为了避免出错还是不要使用这种写法，尤其是驼峰式命名。因为获取<em>dataset</em>时，会看到输出的object中该属性都变为了小写。</li>
</ul>

<h4 id="toc_2">举个例子</h4>

<p>下面这段代码中加入了自定义属性<em>data-bgColor</em>，采用了驼峰式命名，希望能够记住该属性通过JavaScript动态赋值。</p>

<pre><code class="language-html">&lt;div id=&quot;container2&quot; data-bgColor=&quot;yellow&quot;&gt;&lt;/div&gt;
</code></pre>

<p>可是通过JavaScript获取到该属性时，却变为了小写。如下图。</p>

<pre><code class="language-javascript">var container2 = document.getElementById(&#39;container2&#39;);
var dataset2 = container2.dataset;
console.log(dataset2);
</code></pre>

<p><img src="media/14924956119427/14924968409115.jpg" alt=""/></p>

<p>那如果非要使用驼峰式命名该如何呢？上面有个例子举得好像正好规避了这个问题。有这样的一个属性<em>data-name-1</em>，访问到的还是<em>name-1</em>，如果将其换为字符串<em>data-bg-color</em>，可以看到获取的时候就变为了驼峰。</p>

<p><img src="media/14924956119427/14924973616744.jpg" alt=""/></p>

<p>这是因为浏览器有一个<em>Name conversion（命名转换）</em>的过程，在获取时将<em>data-</em>去掉，并且将之后的命名中如果含有破折号的，将其变为大写。当然了，变为大写的字符也是有范围的。首先它必须具有大写，<em>ASCII</em>中的<em>A</em>到<em>Z</em>。</p>

<blockquote>
<p>any dash (U+002D) followed by an ASCII lowercase letter a to z, the dash is removed and the letter is transformed into its uppercase counterpart;</p>
</blockquote>

<p>当然了，这是一个双向的过程。我们也可以给DOM元素指定不存在的<em>data-</em>属性。</p>

<pre><code class="language-javascript">container2.dataset.itemIndex = &quot;1&quot;;
</code></pre>

<p>这时，在<em>HTML</em>中，将会如此渲染。如下图，可以看到又加上了破折号<em>data-item-index</em>。</p>

<p><img src="media/14924956119427/14924980360328.jpg" alt=""/></p>

<blockquote>
<p>any ASCII uppercase letter A to Z is transformed into a dash followed by its lowercase counterpart;</p>
</blockquote>

<h2 id="toc_3">操作</h2>

<p><code>JavaScript</code>来获取data-*属性。</p>

<h3 id="toc_4">获取并操作元素样式</h3>

<pre><code class="language-javascript">var container = document.getElementById(&#39;container&#39;);
var dataset = container.dataset;
container.style = `
width: ${dataset.width};
height: ${dataset.height};
background-color: ${dataset.bgcolor};`;
</code></pre>

<p><img src="media/14924956119427/14924987600651.jpg" alt=""/></p>

<h3 id="toc_5">也可以在选取特定的元素上起作用。</h3>

<pre><code class="language-javascript">const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【摘抄】You Don't Need jQuery (选自 https://travis-ci.org/oneuijs/You-Dont-Need-jQuery)]]></title>
    <link href="beace.github.io/14921760383479.html"/>
    <updated>2017-04-14T21:20:38+08:00</updated>
    <id>beace.github.io/14921760383479.html</id>
    <content type="html"><![CDATA[
<p>前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10+ 以上浏览器。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ol>
<li><a href="#translations">Translations</a></li>
<li><a href="#query-selector">Query Selector</a></li>
<li><a href="#css--style">CSS &amp; Style</a></li>
<li><a href="#dom-manipulation">DOM Manipulation</a></li>
<li><a href="#ajax">Ajax</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#utilities">Utilities</a></li>
<li><a href="#promises">Promises</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#alternatives">Alternatives</a></li>
<li><a href="#browser-support">Browser Support</a></li>
</ol>

<h2 id="toc_1">Translations</h2>

<ul>
<li><a href="./README.ko-KR.md">한국어</a></li>
<li><a href="./README.zh-CN.md">简体中文</a></li>
<li><a href="./README-my.md">Bahasa Melayu</a></li>
<li><a href="./README-id.md">Bahasa Indonesia</a></li>
<li><a href="./README.pt-BR.md">Português(PT-BR)</a></li>
<li><a href="./README-vi.md">Tiếng Việt Nam</a></li>
<li><a href="./README-es.md">Español</a></li>
<li><a href="./README-ru.md">Русский</a></li>
<li><a href="./README-kg.md">Кыргызча</a></li>
<li><a href="./README-tr.md">Türkçe</a></li>
<li><a href="./README-it.md">Italiano</a></li>
<li><a href="./README-fr.md">Français</a></li>
<li><a href="./README-ja.md">日本語</a></li>
<li><a href="./README-pl.md">Polski</a></li>
</ul>

<h2 id="toc_2">Query Selector</h2>

<p>常用的 class、id、属性 选择器都可以使用 <code>document.querySelector</code> 或 <code>document.querySelectorAll</code> 替代。区别是<br/>
* <code>document.querySelector</code> 返回第一个匹配的 Element<br/>
* <code>document.querySelectorAll</code> 返回所有匹配的 Element 组成的 NodeList。它可以通过 <code>[].slice.call()</code> 把它转成 Array<br/>
* 如果匹配不到任何 Element，jQuery 返回空数组 <code>[]</code>，但 <code>document.querySelector</code> 返回 <code>null</code>，注意空指针异常。当找不到时，也可以使用 <code>||</code> 设置默认的值，如 <code>document.querySelectorAll(selector) || []</code></p>

<blockquote>
<p>注意：<code>document.querySelector</code> 和 <code>document.querySelectorAll</code> 性能很<strong>差</strong>。如果想提高性能，尽量使用 <code>document.getElementById</code>、<code>document.getElementsByClassName</code> 或 <code>document.getElementsByTagName</code>。</p>
</blockquote>

<ul>
<li><p><a href="#1.0">1.0</a> <a name='1.0'></a> 选择器查询</p>

<pre><code class="language-js">// jQuery
$(&#39;selector&#39;);

// Native
document.querySelectorAll(&#39;selector&#39;);
</code></pre></li>
<li><p><a href="#1.1">1.1</a> <a name='1.1'></a> class 查询</p>

<pre><code class="language-js">// jQuery
$(&#39;.class&#39;);

// Native
document.querySelectorAll(&#39;.class&#39;);

// or
document.getElementsByClassName(&#39;class&#39;);
</code></pre></li>
<li><p><a href="#1.2">1.2</a> <a name='1.2'></a> id 查询</p>

<pre><code class="language-js">// jQuery
$(&#39;#id&#39;);

// Native
document.querySelector(&#39;#id&#39;);

// or
document.getElementById(&#39;id&#39;);
</code></pre></li>
<li><p><a href="#1.3">1.3</a> <a name='1.3'></a> 属性查询</p>

<pre><code class="language-js">// jQuery
$(&#39;a[target=_blank]&#39;);

// Native
document.querySelectorAll(&#39;a[target=_blank]&#39;);
</code></pre></li>
<li><p><a href="#1.4">1.4</a> <a name='1.4'></a> 后代查询</p>

<pre><code class="language-js">// jQuery
$el.find(&#39;li&#39;);

// Native
el.querySelectorAll(&#39;li&#39;);
</code></pre></li>
<li><p><a href="#1.5">1.5</a> <a name='1.5'></a> 兄弟及上下元素</p>

<ul>
<li>兄弟元素</li>
</ul>

<pre><code class="language-js">// jQuery
$el.siblings();

// Native - latest, Edge13+
[...el.parentNode.children].filter((child) =&gt;
  child !== el
);
// Native (alternative) - latest, Edge13+
Array.from(el.parentNode.children).filter((child) =&gt;
  child !== el
);
// Native - IE10+
Array.prototype.filter.call(el.parentNode.children, (child) =&gt;
  child !== el
);
</code></pre>

<ul>
<li>上一个元素</li>
</ul>

<pre><code class="language-js">// jQuery
$el.prev();

// Native
el.previousElementSibling;

</code></pre>

<ul>
<li>下一个元素</li>
</ul>

<pre><code class="language-js">// next
$el.next();

// Native
el.nextElementSibling;
</code></pre></li>
<li><p><a href="#1.6">1.6</a> <a name='1.6'></a> Closest</p>

<p>Closest 获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。</p>

<pre><code class="language-js">// jQuery
$el.closest(queryString);

// Native - Only latest, NO IE
el.closest(selector);

// Native - IE10+
function closest(el, selector) {
const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

while (el) {
  if (matchesSelector.call(el, selector)) {
    return el;
  } else {
    el = el.parentElement;
  }
}
return null;
}
</code></pre></li>
<li><p><a href="#1.7">1.7</a> <a name='1.7'></a> Parents Until</p>

<p>获取当前每一个匹配元素集的祖先，不包括匹配元素的本身。</p>

<pre><code class="language-js">// jQuery
$el.parentsUntil(selector, filter);

// Native
function parentsUntil(el, selector, filter) {
const result = [];
const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

// match start from parent
el = el.parentElement;
while (el &amp;&amp; !matchesSelector.call(el, selector)) {
  if (!filter) {
    result.push(el);
  } else {
    if (matchesSelector.call(el, filter)) {
      result.push(el);
    }
  }
  el = el.parentElement;
}
return result;
}
</code></pre></li>
<li><p><a href="#1.8">1.8</a> <a name='1.8'></a> Form</p>

<ul>
<li>Input/Textarea</li>
</ul>

<pre><code class="language-js">// jQuery
$(&#39;#my-input&#39;).val();

// Native
document.querySelector(&#39;#my-input&#39;).value;
</code></pre>

<ul>
<li>获取 e.currentTarget 在 <code>.radio</code> 中的数组索引</li>
</ul>

<pre><code class="language-js">// jQuery
$(&#39;.radio&#39;).index(e.currentTarget);

// Native
Array.prototype.indexOf.call(document.querySelectorAll(&#39;.radio&#39;), e.currentTarget);
</code></pre></li>
<li><p><a href="#1.9">1.9</a> <a name='1.9'></a> Iframe Contents</p>

<p>jQuery 对象的 iframe <code>contents()</code> 返回的是 iframe 内的 <code>document</code></p>

<ul>
<li>Iframe contents</li>
</ul>

<pre><code class="language-js">// jQuery
$iframe.contents();

// Native
iframe.contentDocument;
</code></pre>

<ul>
<li>Iframe Query</li>
</ul>

<pre><code class="language-js">// jQuery
$iframe.contents().find(&#39;.css&#39;);

// Native
iframe.contentDocument.querySelectorAll(&#39;.css&#39;);
</code></pre></li>
<li><p><a href="#1.10">1.10</a> <a name='1.10'></a> 获取 body</p>

<pre><code class="language-js">// jQuery
$(&#39;body&#39;);

// Native
document.body;
</code></pre></li>
<li><p><a href="#1.11">1.11</a> <a name='1.11'></a> 获取或设置属性</p>

<ul>
<li>获取属性</li>
</ul>

<pre><code class="language-js">// jQuery
$el.attr(&#39;foo&#39;);

// Native
el.getAttribute(&#39;foo&#39;);
</code></pre>

<ul>
<li>设置属性</li>
</ul>

<pre><code class="language-js">// jQuery, note that this works in memory without change the DOM
$el.attr(&#39;foo&#39;, &#39;bar&#39;);

// Native
el.setAttribute(&#39;foo&#39;, &#39;bar&#39;);
</code></pre>

<ul>
<li>获取 <code>data-</code> 属性</li>
</ul>

<pre><code class="language-js">// jQuery
$el.data(&#39;foo&#39;);

// Native (use `getAttribute`)
el.getAttribute(&#39;data-foo&#39;);

// Native (use `dataset` if only need to support IE 11+)
el.dataset[&#39;foo&#39;];
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_3">CSS &amp; Style</h2>

<ul>
<li><p><a href="#2.1">2.1</a> <a name='2.1'></a> CSS</p>

<ul>
<li>Get style</li>
</ul>

<pre><code class="language-js">// jQuery
$el.css(&quot;color&quot;);

// Native
// 注意：此处为了解决当 style 值为 auto 时，返回 auto 的问题
const win = el.ownerDocument.defaultView;

// null 的意思是不返回伪类元素
win.getComputedStyle(el, null).color;
</code></pre>

<ul>
<li>Set style</li>
</ul>

<pre><code class="language-js">// jQuery
$el.css({ color: &quot;#ff0011&quot; });

// Native
el.style.color = &#39;#ff0011&#39;;
</code></pre>

<ul>
<li>Get/Set Styles</li>
</ul>

<p>注意，如果想一次设置多个 style，可以参考 oui-dom-utils 中 <a href="https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L194">setStyles</a> 方法</p>

<ul>
<li>Add class</li>
</ul>

<pre><code class="language-js">// jQuery
$el.addClass(className);

// Native
el.classList.add(className);
</code></pre>

<ul>
<li>Remove class</li>
</ul>

<pre><code class="language-js">// jQuery
$el.removeClass(className);

// Native
el.classList.remove(className);
</code></pre>

<ul>
<li>has class</li>
</ul>

<pre><code class="language-js">// jQuery
$el.hasClass(className);

// Native
el.classList.contains(className);
</code></pre>

<ul>
<li>Toggle class</li>
</ul>

<pre><code class="language-js">// jQuery
$el.toggleClass(className);

// Native
el.classList.toggle(className);
</code></pre></li>
<li><p><a href="#2.2">2.2</a> <a name='2.2'></a> Width &amp; Height</p>

<p>Width 与 Height 获取方法相同，下面以 Height 为例：</p>

<ul>
<li>Window height</li>
</ul>

<pre><code class="language-js">// window height
$(window).height();

// 含 scrollbar
window.document.documentElement.clientHeight;

// 不含 scrollbar，与 jQuery 行为一致
window.innerHeight;
</code></pre>

<ul>
<li>Document height</li>
</ul>

<pre><code class="language-js">// jQuery
$(document).height();

// Native
const body = document.body;
const html = document.documentElement;
const height = Math.max(
  body.offsetHeight,
  body.scrollHeight,
  html.clientHeight,
  html.offsetHeight,
  html.scrollHeight
);
</code></pre>

<ul>
<li>Element height</li>
</ul>

<pre><code class="language-js">// jQuery
$el.height();

// Native
function getHeight(el) {
  const styles = this.getComputedStyle(el);
  const height = el.offsetHeight;
  const borderTopWidth = parseFloat(styles.borderTopWidth);
  const borderBottomWidth = parseFloat(styles.borderBottomWidth);
  const paddingTop = parseFloat(styles.paddingTop);
  const paddingBottom = parseFloat(styles.paddingBottom);
  return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;
}

// 精确到整数（border-box 时为 height - border 值，content-box 时为 height + padding 值）
el.clientHeight;

// 精确到小数（border-box 时为 height 值，content-box 时为 height + padding + border 值）
el.getBoundingClientRect().height;
</code></pre></li>
<li><p><a href="#2.3">2.3</a> <a name='2.3'></a> Position &amp; Offset</p>

<ul>
<li>Position</li>
</ul>

<p>获得匹配元素相对父元素的偏移</p>

<pre><code class="language-js">// jQuery
$el.position();

// Native
{ left: el.offsetLeft, top: el.offsetTop }
</code></pre>

<ul>
<li>Offset</li>
</ul>

<p>获得匹配元素相对文档的偏移</p>

<pre><code class="language-js">// jQuery
$el.offset();

// Native
function getOffset (el) {
  const box = el.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset - document.documentElement.clientTop,
    left: box.left + window.pageXOffset - document.documentElement.clientLeft
  }
}
</code></pre></li>
<li><p><a href="#2.4">2.4</a> <a name='2.4'></a> Scroll Top</p>

<p>获取元素滚动条垂直位置。</p>

<pre><code class="language-js">// jQuery
$(window).scrollTop();

// Native
(document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_4">DOM Manipulation</h2>

<ul>
<li><p><a href="#3.1">3.1</a> <a name='3.1'></a> Remove</p>

<p>从 DOM 中移除元素。</p>

<pre><code class="language-js">// jQuery
$el.remove();

// Native
el.parentNode.removeChild(el);
</code></pre></li>
<li><p><a href="#3.2">3.2</a> <a name='3.2'></a> Text</p>

<ul>
<li>Get text</li>
</ul>

<p>返回指定元素及其后代的文本内容。</p>

<pre><code class="language-js">// jQuery
$el.text();

// Native
el.textContent;
</code></pre>

<ul>
<li>Set text</li>
</ul>

<p>设置元素的文本内容。</p>

<pre><code class="language-js">// jQuery
$el.text(string);

// Native
el.textContent = string;
</code></pre></li>
<li><p><a href="#3.3">3.3</a> <a name='3.3'></a> HTML</p>

<ul>
<li>Get HTML</li>
</ul>

<pre><code class="language-js">// jQuery
$el.html();

// Native
el.innerHTML;
</code></pre>

<ul>
<li>Set HTML</li>
</ul>

<pre><code class="language-js">// jQuery
$el.html(htmlString);

// Native
el.innerHTML = htmlString;
</code></pre></li>
<li><p><a href="#3.4">3.4</a> <a name='3.4'></a> Append</p>

<p>Append 插入到子节点的末尾</p>

<pre><code class="language-js">// jQuery
$el.append(&quot;&lt;div id=&#39;container&#39;&gt;hello&lt;/div&gt;&quot;);

// Native (HTML string)
el.insertAdjacentHTML(&#39;beforeend&#39;, &#39;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#39;);

// Native (Element)
el.appendChild(newEl);
</code></pre></li>
<li><p><a href="#3.5">3.5</a> <a name='3.5'></a> Prepend</p>

<pre><code class="language-js">// jQuery
$el.prepend(&quot;&lt;div id=&#39;container&#39;&gt;hello&lt;/div&gt;&quot;);

// Native (HTML string)
el.insertAdjacentHTML(&#39;afterbegin&#39;, &#39;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#39;);

// Native (Element)
el.insertBefore(newEl, el.firstChild);
</code></pre></li>
<li><p><a href="#3.6">3.6</a> <a name='3.6'></a> insertBefore</p>

<p>在选中元素前插入新节点</p>

<pre><code class="language-js">// jQuery
$newEl.insertBefore(queryString);

// Native (HTML string)
el.insertAdjacentHTML(&#39;beforebegin &#39;, &#39;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#39;);

// Native (Element)
const el = document.querySelector(selector);
if (el.parentNode) {
el.parentNode.insertBefore(newEl, el);
}
</code></pre></li>
<li><p><a href="#3.7">3.7</a> <a name='3.7'></a> insertAfter</p>

<p>在选中元素后插入新节点</p>

<pre><code class="language-js">// jQuery
$newEl.insertAfter(queryString);

// Native (HTML string)
el.insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div id=&quot;container&quot;&gt;Hello World&lt;/div&gt;&#39;);

// Native (Element)
const el = document.querySelector(selector);
if (el.parentNode) {
el.parentNode.insertBefore(newEl, el.nextSibling);
}
</code></pre></li>
<li><p><a href="#3.8">3.8</a> <a name='3.8'></a> is</p>

<p>如果匹配查询选择器则 <code>true</code></p>

<pre><code class="language-js">// jQuery - Notice `is` also work with `function` or `elements` which is not concerned here
$el.is(selector);

// Native
el.matches(selector);
</code></pre></li>
<li><p><a href="#3.9">3.9</a> <a name='3.9'></a> clone</p>

<p>创建元素的深度拷贝</p>

<pre><code class="language-js">// jQuery
$el.clone();

// Native
el.cloneNode();

// For Deep clone , set param as `true`
</code></pre></li>
<li><p><a href="#3.10">3.10</a> <a name='3.10'></a> empty</p>

<p>移除所有子节点</p>

<pre><code class="language-js">// jQuery
$el.empty();

// Native
el.innerHTML = &#39;&#39;;
</code></pre></li>
<li><p><a href="#3.11">3.11</a> <a name='3.11'></a> wrap</p>

<p>使用 HTML 结构包装每个元素</p>

<pre><code class="language-js">// jQuery
$(&#39;.inner&#39;).wrap(&#39;&lt;div class=&quot;wrapper&quot;&gt;&lt;/div&gt;&#39;);

// Native
Array.prototype.forEach.call(document.querySelectorAll(&#39;.inner&#39;), (el) =&gt; {
const wrapper = document.createElement(&#39;div&#39;);
wrapper.className = &#39;wrapper&#39;;
el.parentNode.insertBefore(wrapper, el);
el.parentNode.removeChild(el);
wrapper.appendChild(el);
});
</code></pre></li>
<li><p><a href="#3.12">3.12</a> <a name='3.12'></a> unwrap</p>

<p>从 DOM 中移除匹配元素的父集</p>

<pre><code class="language-js">// jQuery
$(&#39;.inner&#39;).unwrap();

// Native
Array.prototype.forEach.call(document.querySelectorAll(&#39;.inner&#39;), (el) =&gt; {
Array.prototype.forEach.call(el.childNodes, (child) =&gt; {
  el.parentNode.insertBefore(child, el);
});
el.parentNode.removeChild(el);
});
</code></pre></li>
<li><p><a href="#3.13">3.13</a> <a name='3.13'></a> replaceWith</p>

<p>使用提供的新内容替换匹配元素的内容</p>

<pre><code class="language-js">// jQuery
$(&#39;.inner&#39;).replaceWith(&#39;&lt;div class=&quot;outer&quot;&gt;&lt;/div&gt;&#39;);

// Native
Array.prototype.forEach.call(document.querySelectorAll(&#39;.inner&#39;), (el) =&gt; {
const outer = document.createElement(&#39;div&#39;);
outer.className = &#39;outer&#39;;
el.parentNode.insertBefore(outer, el);
el.parentNode.removeChild(el);
});
</code></pre></li>
<li><p><a href="#3.8">3.8</a> <a name='3.8'></a> is</p>

<p>如果匹配给定的选择器，返回true</p>

<pre><code class="language-js">// jQuery
$el.is(selector);

// Native
el.matches(selector);
</code></pre></li>
<li><p><a href="#3.9">3.9</a> <a name='3.9'></a> clone</p>

<p>深拷贝被选元素。（生成被选元素的副本，包含子节点、文本和属性。）</p>

<pre><code class="language-js">//jQuery
$el.clone();

//Native
el.cloneNode();
</code></pre></li>
<li><p><a href="#3.10">3.10</a> <a name='3.10'></a> empty</p>

<p>移除所有子节点</p></li>
</ul>

<pre><code class="language-js">//jQuery
$el.empty();

//Native
el.innerHTML = &#39;&#39;;
</code></pre>

<p>-<a href="#3.11">3.11</a> <a name='3.11'></a> wrap</p>

<p>把每个被选元素放置在指定的HTML结构中。</p>

<pre><code class="language-js"> //jQuery
 $(&quot;.inner&quot;).wrap(&#39;&lt;div class=&quot;wrapper&quot;&gt;&lt;/div&gt;&#39;);

 //Native
 Array.prototype.forEach.call(document.querySelector(&#39;.inner&#39;), (el) =&gt; {
   const wrapper = document.createElement(&quot;div&quot;);
   wrapper.className = &quot;wrapper&quot;;
   el.parentNode.
 });

</code></pre>

<p>-<a href="#3.12">3.12</a> <a name="3.12"></a> unwrap</p>

<p>把被选元素的父元素移除DOM结构</p>

<pre><code class="language-js">  //jQuery
  $(&quot;.inner&quot;).unwrap();

  //Native
  Array.prototype.forEach.call(document.querySelectorAll(&#39;.inner&#39;), (el) =&gt; {
  Array.prototype.forEach.call(el.childNodes, (child) =&gt; {
    el.parentNode.insertBefore(child, el);
  });
  el.parentNode.removeChild(el);
});
</code></pre>

<p>-<a href="#3.13">3.13</a> <a name="3.13"></a> replaceWith</p>

<p>用指定的元素替换被选的元素</p>

<pre><code class="language-js">  //jQuery
  $(&#39;.inner&#39;).replaceWith(&#39;&lt;div class=&quot;outer&quot;&gt;&lt;/div&gt;&#39;);

  //Native
  Array.prototype.forEach.call(document.querySelectorAll(&#39;.inner&#39;),(el) =&gt; {
    const outer = document.createElement(&quot;div&quot;);
    outer.className = &quot;outer&quot;;
    el.parentNode.insertBefore(outer, el);
    el.parentNode.removeChild(el);
  });
</code></pre>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_5">Ajax</h2>

<p><a href="https://fetch.spec.whatwg.org/">Fetch API</a> 是用于替换 XMLHttpRequest 处理 ajax 的新标准，Chrome 和 Firefox 均支持，旧浏览器可以使用 polyfills 提供支持。</p>

<p>IE9+ 请使用 <a href="http://github.com/github/fetch">github/fetch</a>，IE8+ 请使用 <a href="https://github.com/camsong/fetch-ie8/">fetch-ie8</a>，JSONP 请使用 <a href="https://github.com/camsong/fetch-jsonp">fetch-jsonp</a>。</p>

<ul>
<li><p><a href="#4.1">4.1</a> <a name='4.1'></a> 从服务器读取数据并替换匹配元素的内容。</p>

<pre><code class="language-js">// jQuery
$(selector).load(url, completeCallback)

// Native
fetch(url).then(data =&gt; data.text()).then(data =&gt; {
document.querySelector(selector).innerHTML = data
}).then(completeCallback)
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_6">Events</h2>

<p>完整地替代命名空间和事件代理，链接到 <a href="https://github.com/oneuijs/oui-dom-events">https://github.com/oneuijs/oui-dom-events</a></p>

<ul>
<li><p><a href="#5.0">5.0</a> <a name='5.0'></a> Document ready by <code>DOMContentLoaded</code></p>

<pre><code class="language-js">// jQuery
$(document).ready(eventHandler);

// Native
// 检测 DOMContentLoaded 是否已完成
if (document.readyState === &#39;complete&#39; || document.readyState !== &#39;loading&#39;) {
eventHandler();
} else {
document.addEventListener(&#39;DOMContentLoaded&#39;, eventHandler);
}
</code></pre></li>
<li><p><a href="#5.1">5.1</a> <a name='5.1'></a> 使用 on 绑定事件</p>

<pre><code class="language-js">// jQuery
$el.on(eventName, eventHandler);

// Native
el.addEventListener(eventName, eventHandler);
</code></pre></li>
<li><p><a href="#5.2">5.2</a> <a name='5.2'></a> 使用 off 解绑事件</p>

<pre><code class="language-js">// jQuery
$el.off(eventName, eventHandler);

// Native
el.removeEventListener(eventName, eventHandler);
</code></pre></li>
<li><p><a href="#5.3">5.3</a> <a name='5.3'></a> Trigger</p>

<pre><code class="language-js">// jQuery
$(el).trigger(&#39;custom-event&#39;, {key1: &#39;data&#39;});

// Native
if (window.CustomEvent) {
const event = new CustomEvent(&#39;custom-event&#39;, {detail: {key1: &#39;data&#39;}});
} else {
const event = document.createEvent(&#39;CustomEvent&#39;);
event.initCustomEvent(&#39;custom-event&#39;, true, true, {key1: &#39;data&#39;});
}

el.dispatchEvent(event);
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_7">Utilities</h2>

<p>大部分实用工具都能在 native API 中找到. 其他高级功能可以选用专注于该领域的稳定性和性能都更好的库来代替，推荐 <a href="https://lodash.com">lodash</a>。</p>

<ul>
<li><p><a href="#6.1">6.1</a> <a name='6.1'></a> 基本工具</p>

<ul>
<li>isArray</li>
</ul>

<p>检测参数是不是数组。</p>

<pre><code class="language-js">// jQuery
$.isArray(range);

// Native
Array.isArray(range);
</code></pre>

<ul>
<li>isWindow</li>
</ul>

<p>检测参数是不是 window。</p>

<pre><code class="language-js">// jQuery
$.isWindow(obj);

// Native
function isWindow(obj) {
return obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window;
}
</code></pre>

<ul>
<li>inArray</li>
</ul>

<p>在数组中搜索指定值并返回索引 (找不到则返回 -1)。</p>

<pre><code class="language-js">// jQuery
$.inArray(item, array);

// Native
array.indexOf(item) &gt; -1;

// ES6-way
array.includes(item);
</code></pre>

<ul>
<li>isNumeric</li>
</ul>

<p>检测传入的参数是不是数字。<br/>
Use <code>typeof</code> to decide the type or the <code>type</code> example for better accuracy.</p>

<pre><code class="language-js">// jQuery
$.isNumeric(item);

// Native
function isNumeric(value) {
var type = typeof value;

return (type === &#39;number&#39; || type === &#39;string&#39;) &amp;&amp; !Number.isNaN(value - Number.parseFloat(value));
}
</code></pre>

<ul>
<li>isFunction</li>
</ul>

<p>检测传入的参数是不是 JavaScript 函数对象。</p>

<pre><code class="language-js">// jQuery
$.isFunction(item);

// Native
function isFunction(item) {
if (typeof item === &#39;function&#39;) {
  return true;
}
var type = Object.prototype.toString(item);
return type === &#39;[object Function]&#39; || type === &#39;[object GeneratorFunction]&#39;;
}
</code></pre>

<ul>
<li>isEmptyObject</li>
</ul>

<p>检测对象是否为空 (包括不可枚举属性).</p>

<pre><code class="language-js">// jQuery
$.isEmptyObject(obj);

// Native
function isEmptyObject(obj) {
return Object.keys(obj).length === 0;
}
</code></pre>

<ul>
<li>isPlainObject</li>
</ul>

<p>检测是不是扁平对象 (使用 “{}” 或 “new Object” 创建).</p>

<pre><code class="language-js">// jQuery
$.isPlainObject(obj);

// Native
function isPlainObject(obj) {
if (typeof (obj) !== &#39;object&#39; || obj.nodeType || obj !== null &amp;&amp; obj !== undefined &amp;&amp; obj === obj.window) {
  return false;
}

if (obj.constructor &amp;&amp;
    !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, &#39;isPrototypeOf&#39;)) {
  return false;
}

return true;
}
</code></pre>

<ul>
<li>extend</li>
</ul>

<p>合并多个对象的内容到第一个对象。<br/>
object.assign 是 ES6 API，也可以使用 <a href="https://github.com/ljharb/object.assign">polyfill</a>。</p>

<pre><code class="language-js">// jQuery
$.extend({}, defaultOpts, opts);

// Native
Object.assign({}, defaultOpts, opts);
</code></pre>

<ul>
<li>trim</li>
</ul>

<p>移除字符串头尾空白。</p>

<pre><code class="language-js">// jQuery
$.trim(string);

// Native
string.trim();
</code></pre>

<ul>
<li>map</li>
</ul>

<p>将数组或对象转化为包含新内容的数组。</p>

<pre><code class="language-js">// jQuery
$.map(array, (value, index) =&gt; {
});

// Native
array.map((value, index) =&gt; {
});
</code></pre>

<ul>
<li>each</li>
</ul>

<p>轮询函数，可用于平滑的轮询对象和数组。</p>

<pre><code class="language-js">// jQuery
$.each(array, (index, value) =&gt; {
});

// Native
array.forEach((value, index) =&gt; {
});
</code></pre>

<ul>
<li>grep</li>
</ul>

<p>找到数组中符合过滤函数的元素。</p>

<pre><code class="language-js">// jQuery
$.grep(array, (value, index) =&gt; {
});

// Native
array.filter((value, index) =&gt; {
});
</code></pre>

<ul>
<li>type</li>
</ul>

<p>检测对象的 JavaScript [Class] 内部类型。</p>

<pre><code class="language-js">// jQuery
$.type(obj);

// Native
function type(item) {
const reTypeOf = /(?:^\[object\s(.*?)\]$)/;
return Object.prototype.toString.call(item)
  .replace(reTypeOf, &#39;$1&#39;)
  .toLowerCase();
}
</code></pre>

<ul>
<li>merge</li>
</ul>

<p>合并第二个数组内容到第一个数组。</p>

<pre><code class="language-js">// jQuery
$.merge(array1, array2);

// Native
// But concat function doesn&#39;t remove duplicate items.
function merge(...args) {
return [].concat(...args)
}
</code></pre>

<ul>
<li>now</li>
</ul>

<p>返回当前时间的数字呈现。</p>

<pre><code class="language-js">// jQuery
$.now();

// Native
Date.now();
</code></pre>

<ul>
<li>proxy</li>
</ul>

<p>传入函数并返回一个新函数，该函数绑定指定上下文。</p>

<pre><code class="language-js">// jQuery
$.proxy(fn, context);

// Native
fn.bind(context);
</code></pre>

<ul>
<li>makeArray</li>
</ul>

<p>类数组对象转化为真正的 JavaScript 数组。</p>

<pre><code class="language-js">// jQuery
$.makeArray(arrayLike);

// Native
Array.prototype.slice.call(arrayLike);

// ES6-way
Array.from(arrayLike);
</code></pre></li>
<li><p><a href="#6.2">6.2</a> <a name='6.2'></a> 包含</p>

<p>检测 DOM 元素是不是其他 DOM 元素的后代.</p>

<pre><code class="language-js">// jQuery
$.contains(el, child);

// Native
el !== child &amp;&amp; el.contains(child);
</code></pre></li>
<li><p><a href="#6.3">6.3</a> <a name='6.3'></a> Globaleval</p>

<p>全局执行 JavaScript 代码。</p>

<pre><code class="language-js">// jQuery
$.globaleval(code);

// Native
function Globaleval(code) {
const script = document.createElement(&#39;script&#39;);
script.text = code;

document.head.appendChild(script).parentNode.removeChild(script);
}

// Use eval, but context of eval is current, context of $.Globaleval is global.
eval(code);
</code></pre></li>
<li><p><a href="#6.4">6.4</a> <a name='6.4'></a> 解析</p>

<ul>
<li>parseHTML</li>
</ul>

<p>解析字符串为 DOM 节点数组.</p>

<pre><code class="language-js">// jQuery
$.parseHTML(htmlString);

// Native
function parseHTML(string) {
const context = document.implementation.createHTMLDocument();

// Set the base href for the created document so any parsed elements with URLs
// are based on the document&#39;s URL
const base = context.createElement(&#39;base&#39;);
base.href = document.location.href;
context.head.appendChild(base);

context.body.innerHTML = string;
return context.body.children;
}
</code></pre>

<ul>
<li>parseJSON</li>
</ul>

<p>传入格式正确的 JSON 字符串并返回 JavaScript 值.</p>

<pre><code class="language-js">// jQuery
$.parseJSON(str);

// Native
JSON.parse(str);
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_8">Promises</h2>

<p>Promise 代表异步操作的最终结果。jQuery 用它自己的方式处理 promises，原生 JavaScript 遵循 <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> 标准实现了最小 API 来处理 promises。</p>

<ul>
<li><p><a href="#7.1">7.1</a> <a name='7.1'></a> done, fail, always</p>

<p><code>done</code> 会在 promise 解决时调用，<code>fail</code> 会在 promise 拒绝时调用，<code>always</code> 总会调用。</p>

<pre><code class="language-js">// jQuery
$promise.done(doneCallback).fail(failCallback).always(alwaysCallback)

// Native
promise.then(doneCallback, failCallback).then(alwaysCallback, alwaysCallback)
</code></pre></li>
<li><p><a href="#7.2">7.2</a> <a name='7.2'></a> when</p>

<p><code>when</code> 用于处理多个 promises。当全部 promises 被解决时返回，当任一 promise 被拒绝时拒绝。</p>

<pre><code class="language-js">// jQuery
$.when($promise1, $promise2).done((promise1Result, promise2Result) =&gt; {
});

// Native
Promise.all([$promise1, $promise2]).then([promise1Result, promise2Result] =&gt; {});
</code></pre></li>
<li><p><a href="#7.3">7.3</a> <a name='7.3'></a> Deferred</p>

<p>Deferred 是创建 promises 的一种方式。</p>

<pre><code class="language-js">// jQuery
function asyncFunc() {
const defer = new $.Deferred();
setTimeout(() =&gt; {
  if(true) {
    defer.resolve(&#39;some_value_computed_asynchronously&#39;);
  } else {
    defer.reject(&#39;failed&#39;);
  }
}, 1000);

return defer.promise();
}

// Native
function asyncFunc() {
return new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    if (true) {
      resolve(&#39;some_value_computed_asynchronously&#39;);
    } else {
      reject(&#39;failed&#39;);
    }
  }, 1000);
});
}

// Deferred way
function defer() {
const deferred = {};
const promise = new Promise((resolve, reject) =&gt; {
  deferred.resolve = resolve;
  deferred.reject = reject;
});

deferred.promise = () =&gt; {
  return promise;
};

return deferred;
}

function asyncFunc() {
const defer = defer();
setTimeout(() =&gt; {
  if(true) {
    defer.resolve(&#39;some_value_computed_asynchronously&#39;);
  } else {
    defer.reject(&#39;failed&#39;);
  }
}, 1000);

return defer.promise();
}
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_9">Animation</h2>

<ul>
<li><p><a href="#8.1">8.1</a> <a name='8.1'></a> Show &amp; Hide</p>

<pre><code class="language-js">// jQuery
$el.show();
$el.hide();

// Native
// 更多 show 方法的细节详见 https://github.com/oneuijs/oui-dom-utils/blob/master/src/index.js#L363
el.style.display = &#39;&#39;|&#39;inline&#39;|&#39;inline-block&#39;|&#39;inline-table&#39;|&#39;block&#39;;
el.style.display = &#39;none&#39;;
</code></pre></li>
<li><p><a href="#8.2">8.2</a> <a name='8.2'></a> Toggle</p>

<p>显示或隐藏元素。</p>

<pre><code class="language-js">// jQuery
$el.toggle();

// Native
if (el.ownerDocument.defaultView.getComputedStyle(el, null).display === &#39;none&#39;) {
el.style.display = &#39;&#39;|&#39;inline&#39;|&#39;inline-block&#39;|&#39;inline-table&#39;|&#39;block&#39;;
} else {
el.style.display = &#39;none&#39;;
}
</code></pre></li>
<li><p><a href="#8.3">8.3</a> <a name='8.3'></a> FadeIn &amp; FadeOut</p>

<pre><code class="language-js">// jQuery
$el.fadeIn(3000);
$el.fadeOut(3000);

// Native
el.style.transition = &#39;opacity 3s&#39;;
// fadeIn
el.style.opacity = &#39;1&#39;;
// fadeOut
el.style.opacity = &#39;0&#39;;
</code></pre></li>
<li><p><a href="#8.4">8.4</a> <a name='8.4'></a> FadeTo</p>

<p>调整元素透明度。</p>

<pre><code class="language-js">// jQuery
$el.fadeTo(&#39;slow&#39;,0.15);
// Native
el.style.transition = &#39;opacity 3s&#39;; // 假设 &#39;slow&#39; 等于 3 秒
el.style.opacity = &#39;0.15&#39;;
</code></pre></li>
<li><p><a href="#8.5">8.5</a> <a name='8.5'></a> FadeToggle</p>

<p>动画调整透明度用来显示或隐藏。</p>

<pre><code class="language-js">// jQuery
$el.fadeToggle();

// Native
el.style.transition = &#39;opacity 3s&#39;;
const { opacity } = el.ownerDocument.defaultView.getComputedStyle(el, null);
if (opacity === &#39;1&#39;) {
el.style.opacity = &#39;0&#39;;
} else {
el.style.opacity = &#39;1&#39;;
}
</code></pre></li>
<li><p><a href="#8.6">8.6</a> <a name='8.6'></a> SlideUp &amp; SlideDown</p>

<pre><code class="language-js">// jQuery
$el.slideUp();
$el.slideDown();

// Native
const originHeight = &#39;100px&#39;;
el.style.transition = &#39;height 3s&#39;;
// slideUp
el.style.height = &#39;0px&#39;;
// slideDown
el.style.height = originHeight;
</code></pre></li>
<li><p><a href="#8.7">8.7</a> <a name='8.7'></a> SlideToggle</p>

<p>滑动切换显示或隐藏。</p>

<pre><code class="language-js">// jQuery
$el.slideToggle();

// Native
const originHeight = &#39;100px&#39;;
el.style.transition = &#39;height 3s&#39;;
const { height } = el.ownerDocument.defaultView.getComputedStyle(el, null);
if (parseInt(height, 10) === 0) {
el.style.height = originHeight;
}
else {
el.style.height = &#39;0px&#39;;
}
</code></pre></li>
<li><p><a href="#8.8">8.8</a> <a name='8.8'></a> Animate</p>

<p>执行一系列 CSS 属性动画。</p>

<pre><code class="language-js">// jQuery
$el.animate({ params }, speed);

// Native
el.style.transition = &#39;all &#39; + speed;
Object.keys(params).forEach((key) =&gt;
el.style[key] = params[key];
)
</code></pre></li>
</ul>

<p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 回到顶部</a></strong></p>

<h2 id="toc_10">Alternatives</h2>

<ul>
<li><a href="http://youmightnotneedjquery.com/">你可能不需要 jQuery (You Might Not Need jQuery)</a> - 如何使用原生 JavaScript 实现通用事件，元素，ajax 等用法。</li>
<li><a href="http://github.com/npm-dom">npm-dom</a> 以及 <a href="http://github.com/webmodules">webmodules</a> - 在 NPM 上提供独立 DOM 模块的组织</li>
</ul>

<h2 id="toc_11">Browser Support</h2>

<table>
<thead>
<tr>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png" alt="Chrome"/></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png" alt="Firefox"/></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/archive/internet-explorer_9-11/internet-explorer_9-11_48x48.png" alt="IE"/></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png" alt="Opera"/></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png" alt="Safari"/></th>
</tr>
</thead>

<tbody>
<tr>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>10+ ✔</td>
<td>Latest ✔</td>
<td>6.1+ ✔</td>
</tr>
</tbody>
</table>

<h1 id="toc_12">License</h1>

<p>MIT</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Arguments]]></title>
    <link href="beace.github.io/JavaScript-arguments.html"/>
    <updated>2017-03-24T17:26:49+08:00</updated>
    <id>beace.github.io/JavaScript-arguments.html</id>
    <content type="html"><![CDATA[
<p>上一次说到了JavaScript中加引号和不加引号的区别，已经认知到了在大体上还是没有区别的。这里我将深入的了解JavaScript函数中的arguments对象，将其运用到实战。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">正文</a>
</li>
<li>
<a href="#toc_2">Arguments</a>
<ul>
<li>
<a href="#toc_3">arguments中的参数</a>
<ul>
<li>
<a href="#toc_4">特点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">arguments中的arguments.callee属性</a>
</li>
<li>
<a href="#toc_6">arguments个数</a>
</li>
<li>
<a href="#toc_7">arguments@@iterator</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">arguments(object) to array</a>
</li>
</ul>


<h2 id="toc_1">正文</h2>

<p>首先，回顾一下上一次的代码。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments[0])
  console.log(arguments[1])
  console.log(arguments[&#39;0&#39;])
  console.log(arguments[&#39;1&#39;])
}

getArgs(1, 2);

var b = {&quot;b&quot;: &quot;b&quot;};
var b2 = {b: &quot;b&quot;};
console.log(b.b);
console.log(JSON.stringify(b))
console.log(JSON.stringify(b2))
</code></pre>

<p>在这里，我们可以看到其实访问都没有错误。都会返回我们想要的结果。唯一的区别是有引号和没有引号的区别。我们知道JavaScript中表示字符串的时候双引号和单引号是没有区别的（字符串拼接除外），编译器都可以识别。例如上述代码运行时不会出错的。</p>

<p>但是，如果我们想获取getArgs()中参数的个数，可以写成这样吗？</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments.length)
}
</code></pre>

<p>答案是肯定的。但arguments仍然不是一个数组，它是一个只具备length属性的对象。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(typeof arguments); // object
}
</code></pre>

<p>可以看出，arguments是object类型的，只有array类型才具有length属性。那为何可以像数组那样访问呢？ </p>

<p>在这里，先打住。我们来看下array是如何获取元素的。</p>

<pre><code class="language-js">const arr = [1,2,3,4];
for (let i = 0; i &lt; arr.length; i ++) {
  console.log(a[i]); //1 2 3 4
}
</code></pre>

<p>上述代码迭代了arr数组，并且我们通过Array[index]的方式进行数组元素的获取。试想一下，如果给index加上引号呢？还能如期获取吗？</p>

<pre><code class="language-js">//将 console.log(a[i]) 替换
console.log(a[i.toString()]) //1 2 3 4
</code></pre>

<p>可以看到，数组如约输出。不信你可以尝试<code>a[&#39;0&#39;]</code>的方式去访问，依然可以获得元素。</p>

<p><em>这是为什么呢？</em></p>

<p>首先，我们来查看下Array在JavaScript中定义的类型。</p>

<pre><code class="language-js">typeof Array //object
</code></pre>

<p>可以看到，Array是object类型。尽管我们没有必要这样加引号的去访问，但是事实上是可以这样的。因为a[0]中的整型0被JavaScript强制地隐式转换（toString()）为字符串&#39;0&#39;。如果你不相信，Mozilla MDN上有一个非常好的例子来说明这一点 （<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array%EF%BC%89">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array）</a> 。比如：</p>

<p>我们声明一个数组，并且像如下访问。</p>

<pre><code class="language-js">var arr = [1,2,3,4,5];
console.log(arr[01] === arr[1]); // true
//这里 arr[&#39;01&#39;] === undefined
console.log(arr[&#39;01&#39;] === arr[&#39;1&#39;]) // false
</code></pre>

<p>我们知道，在整数的高位补0，十进制里还等于其本身。</p>

<pre><code class="language-js">01 === 1 // true
</code></pre>

<p>而数字作为字符串比较，当然就不同。</p>

<pre><code class="language-js">&#39;01&#39; === &#39;1&#39; //false
</code></pre>

<blockquote>
<p>The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. It is for this reason that &#39;2&#39; and &#39;02&#39; would refer to two different slots on the years object and the following example could be true. —— <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">by Mozilla MDN JavaScript Array</a></p>
</blockquote>

<p>这下你应当知道，原来JavaScript也是通过”强制补引号“的方式进行数组索引的处理。那就不难理解为何arguments也可以这样了。容易进入误区的是arguments[0]这样的访问方式容易让人觉得他就是个数组。对于引号没有研究透彻的JavaScript开发者来说，是很大一个误区。</p>

<h2 id="toc_2">Arguments</h2>

<p>现在正式进入arguments的正题。话说既然arguments是个对象，那它里面有什么呢？</p>

<p><img src="media/14903476099970/14903511503835.jpg" alt=""/></p>

<p>这里打印了showMeArgs(1, 2)中的arguments对象。有如下属性</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>function中的第一个参数</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>function中的第二个参数</td>
</tr>
<tr>
<td>callee</td>
<td>showMeArgs(a, b)</td>
<td>当前执行的函数</td>
</tr>
<tr>
<td>length</td>
<td>2</td>
<td>内置属性，获取参数个数</td>
</tr>
<tr>
<td>iterator</td>
<td>array</td>
<td>返回一个新的Array Iterator对象，该对象包含参数中每个索引的值</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">arguments中的参数</h3>

<p>上面图表中的<code>0,1</code>，即对应形参的<code>a,b</code>。</p>

<h4 id="toc_4">特点</h4>

<ul>
<li>可以通过arguments[0]的方式获取或设置属性，设置属性时，会覆盖实参</li>
</ul>

<pre><code class="language-js">function showMeArgs(a, b) {
  arguments[0] = 10;
  console.log(arguments[0]); //10
  console.log(a + b);
}

showMeArgs(1, 2); //12
</code></pre>

<ul>
<li>当默认参数提供时，实参不会被覆盖</li>
</ul>

<pre><code class="language-js">function showMeArgs(a = 1, b) {
  arguments[0] = 100;
  console.log(a + b);
}
showMeArgs(10, 3) // 13
</code></pre>

<ul>
<li>ES6 当使用省略参数（rest parameters）的写法时，arugments也可以返回</li>
</ul>

<pre><code class="language-js">function showMeArgs(...args) {
  console.log(arguments);
}
showMeArgs(1, 2, 3); // object
</code></pre>

<h3 id="toc_5">arguments中的arguments.callee属性</h3>

<p>包含当前执行的功能。这句话可能有些别扭。通俗一点来说，它可以指代该函数函数体内当前执行的函数。</p>

<p>语言描述可能不太准确，在这里可以看一个例子。</p>

<p>如果有一个数组，这个数组我希望能够求出每个元素从<em>0加到该元素的和</em>并返回。可以这样来实现。</p>

<ul>
<li>先把求和这个动作抽象出来。</li>
</ul>

<pre><code class="language-js">function plus(n) {
  return n === 0 ? 0 : plus(n - 1) + n;
}
</code></pre>

<ul>
<li>接着迭代数组加求和</li>
</ul>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(n =&gt; plus(n)) //[0, 1, 3, 6, 10, 15, 21]
</code></pre>

<p>可以看到，我们通过调用plus()实现了。如果我们觉得业务逻辑比较简单，为了代码简洁，想要把抽象出来的东西放在map方法中。</p>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(n =&gt; n === 0 ? 0 : (n - 1) + n); // [0, 1, 3, 5, 7, 9, 11]
</code></pre>

<p>可以看到并没有按照想要的结果去求和，反而直接计算了。这时我们可以使用callee方法代表一个匿名函数来解决这一问题。</p>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(function(n){
  return n === 0 ? 0 : arguments.callee(n - 1) + n
});
</code></pre>

<p>这个时候，我们就不能够使用ES6箭头函数的新特性了。因为arguments为undefined。</p>

<pre><code class="language-sh">Uncaught ReferenceError: arguments is not defined
</code></pre>

<p>相比之下，其实这种递归调动以及内联函数的写法很不友好。我们无法抽象出想要的方法，并且无法进行进一步的优化。在高阶函数中，经常很多函数作为另一个函数的参数进行传递，这样的写法难以维护。如果大量使用，甚至可能造成性能上的问题，例如不可避免的嵌套的匿名回调函数（callback function）等。将来的可能被废弃掉。</p>

<h3 id="toc_6">arguments个数</h3>

<p>通过arguments.length可以获取函数中参数的个数。<strong>但其不是数组</strong></p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments.length) //2
}
</code></pre>

<h3 id="toc_7">arguments<a href="">@@iterator</a></h3>

<p>Array的迭代器。类似Array.prototype.value的使用，现在除Firefox Nightly版本能够体验外，各大浏览器均不支持。例如：</p>

<pre><code class="language-js">var arr = [&#39;w&#39;, &#39;y&#39;, &#39;k&#39;, &#39;o&#39;, &#39;p&#39;];
var iterator = arr.values();
for (let letter of iterator) {
  console.log(letter);
}
</code></pre>

<h2 id="toc_8">arguments(object) to array</h2>

<p>通过上面的所有表述，我们已经知道arguments已经是一个object类型。那可以通过一定方式将arguments的类型转换为array吗？</p>

<p>可能似乎没有这样的需求。我来介绍一个例子。</p>

<blockquote>
<p>以下灵感来自 <a href="https://t.75team.com/video/">https://t.75team.com/video/</a> JavaScript视频</p>
</blockquote>

<p>比如，你的一个同事或者合作的伙伴写了一个改变元素颜色的函数，如下。</p>

<pre><code class="language-js">function setColor(color, ele) {
  ele.style.color = color;
}
</code></pre>

<p>这个函数看起来没有什么特别，唯一让人看起来别扭的可能是参数的位置。我们可能习惯第一个形参为元素（ele），第二个形参为颜色（color），因此我们可以实现一个方法将参数内容转置， 这里就用到了arguments。</p>

<pre><code class="language-js">function setColorReverse(fn) {
  return function(color, ele) {
    var args = Array.prototype.slice.call(arguments);
    fn.apply(this, args.reverse());
  }
}
setColorReverse(setColor(&#39;container&#39;, &#39;blue&#39;));
</code></pre>

<p>同样，除了像Array.prototype.slice.call(arguments)这样的处理之外，还可以替换为：</p>

<pre><code class="language-js">[].slice.call(arguments) || Array.from(arguments)
</code></pre>

<p>在ES6中，这样写更简单。</p>

<pre><code class="language-js">function reverseArgs(fn) {
  return function(...args) {
    fn.apply(null, [...args].reverse());
  }
}

reverseArgs(setColor)(content, &#39;blue&#39;);  // so the color of content is blue
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript一些有趣的地方]]></title>
    <link href="beace.github.io/javascript-object-funny.html"/>
    <updated>2017-03-16T11:49:34+08:00</updated>
    <id>beace.github.io/javascript-object-funny.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Array-like</h2>

<p>所谓的Array-like,即类数组。其实并不是数组，但是可以像数组一样的进行访问，在这里，仅仅是写法上的一致。其实并不是数组。</p>

<h2 id="toc_1">对象(<em>Object</em>)</h2>

<ul>
<li>对象不加引号和加引号的区别，可以参考该链接（<a href="http://stackoverflow.com/questions/4348478/what-is-the-difference-between-object-keys-with-quotes-and-without-quotes%EF%BC%89">http://stackoverflow.com/questions/4348478/what-is-the-difference-between-object-keys-with-quotes-and-without-quotes）</a></li>
</ul>

<pre><code class="language-js">var a = {a: &quot;a&quot;};
var b = {&quot;b&quot;: &quot;b&quot;};
console.log(a); //&quot;a&quot;
console.log(b); //&quot;b&quot;
</code></pre>

<ul>
<li>特殊情况不可以用<em>点</em>的属性访问</li>
</ul>

<pre><code class="language-js">var a = {0: &quot;a&quot;}; 
console.log(a.0); //Uncaught SyntaxError: Unexpected number
//竟然可以像一个数组进行访问
console.log(a[0]); // &quot;a&quot;
//为了以便区分，可以加上引号
console.log(a[&#39;0&#39;]) // &quot;a&quot;
</code></pre>

<blockquote>
<p>No, the quotes do not make a difference (unless, as you noted, you want to use a key that’s not a valid JavaScript identifier).</p>
</blockquote>

<p>可见，如果符合规范的定义<code>key</code>值，加引号和不加引号是没有区别的。如果你的<code>key</code>值中出现数字或者<code>JavaScript</code>中的关键字，可以通过加引号的方式访问<code>obj[&#39;key&#39;]</code></p>

<h2 id="toc_2">引申</h2>

<p>说到这里，我想引申一个东西，跟上面的对象理解（类数组）完全一致。就是<em>JavaScript</em>函数中的<em>arguments</em>参数。</p>

<p><em>arguments</em>对象是所有<em>JavaScript</em>函数中的局部变量。通过<em>arguments</em>我们可以获取函数中的所有参数。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments[0])
  console.log(arguments[1])  
}

getArgs(1, 2); // 1 2
</code></pre>

<p>通过上述代码，我们可以通过类似数组的方式进行参数的读取，判断等等。接下来的一篇文章将会探索<em>arguments</em>的真正类型以及含义。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(1)——矩形]]></title>
    <link href="beace.github.io/css-draw-rectangle.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-rectangle.html</id>
    <content type="html"><![CDATA[
<p>首先在这里声明，对于<code>css</code>画图来说，大部分的图案的宽度甚至高度都是固定的，就算采用百分比的方式来绘制，也会有最外面的边界限制。尽量在PC端或者响应式要求不太高的场景下进行，当然会有一些比较简单的图案绘制能够适应响应式的方式，可以采用canvas或svg来绘制。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">矩形的堆叠</a>
</li>
<li>
<a href="#toc_2">凹凸形(矩形)</a>
</li>
</ul>


<h2 id="toc_1">矩形的堆叠</h2>

<p>如下图形，可以用来表示服务器。是最简单的一种图形绘制，不需要太多技巧。简单的div嵌套即可完成。为一个注意的地方就是里面的图形，可以用百分比来绘制，这样改变外层div的同时，里面也会相应变化。在这里就省略代码了。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890753662725.jpg" alt=""/></p>

<h2 id="toc_2">凹凸形(矩形)</h2>

<p>其实这种图形（如下图）比较少见，但是常常用来描述端口。原理是几个矩形的堆叠，通过相对定位/绝对定位之后的top属性来固定位置，z-index属性来遮掩上下边框。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890709420668.jpg" alt=""/></p>

<p>你可以设置每个矩形的宽度为百分比，但是最终会于设计图相差甚远。而且，还要去考虑绝对定位元素居中的问题，当然这不是很困难。但是如果你的场景没有那么复杂，你可以像我这样来写。</p>

<p>先固定最外面盒子的宽高，然后通过top的属性值来决定元素的上下堆叠位置，left为居中设置。border设置边框的有无，z-index属性决定元素垂直屏幕的层级关系。从下往上，逐层的z-index逐渐变大。</p>

<pre><code class="language-css">.switch-wrapper{
  width: 54px;
  position: relative;
  height: 30px;  
}
.switch{
  border: 2px solid #000;
  margin: 0 auto;
  position: absolute;
  background-color: #fff;
}
.switch-1,
.switch-2 {
  border-bottom: 0;
}
.switch-1{
  width: 14px;
  height: 4px;
  z-index: 3;
  left: 18px;
}
.switch-2 {
  width: 30px;
  height: 6px;
  z-index: 2;
  top: 4px;
  left: 10px;
}
.switch-3 {
  width: 50px;
  height: 16px;
  font-size: 12px;
  text-align: center;
  line-height: 15px;
  z-index: 1;
  bottom: 0;
}
</code></pre>

<pre><code class="language-html">&lt;div className=&quot;switch-wrapper&quot;&gt;
    &lt;div className=&quot;switch switch-1&quot;&gt;&lt;/div&gt;
    &lt;div className=&quot;switch switch-2&quot;&gt;&lt;/div&gt;
    &lt;div className=&quot;switch switch-3&quot;&gt;G0/1&lt;/div&gt;
&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(2)——三角形]]></title>
    <link href="beace.github.io/css-draw-triangle.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-triangle.html</id>
    <content type="html"><![CDATA[
<p>三角形相对来说比较简单，我们可以通过设置border属性轻易实现。我来实现一个简单的和一个有难度的。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">三角形（简单）</a>
<ul>
<li>
<a href="#toc_2">留下一个思考题。</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">三角形（复杂）</a>
</li>
</ul>


<h2 id="toc_1">三角形（简单）</h2>

<p>通过设置三角形（如下图）的四个边的不同颜色，来实现三角形的绘制。其中，包括直角三角形、等边三角形等特殊三角形。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890722556585.jpg" alt=""/></p>

<p>其实从严格意义上来说这不是一个三角形(如下图)，只不过我们看到的是一个三角形的形状。它的形成过程是这样的。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890732104056.jpg" alt=""/></p>

<p>如下图所示，它并非只占有一个三角形的区域，而是一个正方形div盒子。类似一张三角形的png图片，右上方是透明的。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890723173742.jpg" alt=""/></p>

<p>下面展示了一个直角三角形的实现方式。</p>

<pre><code class="language-css">.triangle {
    width: 0;
    height: 0;
    border-right: 50px solid transparent;
    border-bottom: 50px solid #abcdef;
}
</code></pre>

<pre><code class="language-html">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;
</code></pre>

<h3 id="toc_2">留下一个思考题。</h3>

<p>回顾一个三角形的变化那张图，细心的可以发现，边框所设置的宽度，与div盒子占有的宽高好像不太一致。如下图，我设置了每个方向的 border 都为100px,为何占有的宽度为99.2呢？</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890735852383.jpg" alt=""/></p>

<h2 id="toc_3">三角形（复杂）</h2>

<p>我们来实现一个比较常用的tooltip效果。做这样的一个效果（如下图）有很多方法。比如通过三角形的堆叠差异，来实现三角形的两条线。或者先绘制一个三角形，然后将两个线定位到三角形的边上。其实都不优雅，因为我们知道通过border来绘制三角形只能填充其border-color，没有办法描边。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890739284055.jpg" alt=""/></p>

<p>在这里，我采用一种比较独特的方法。为了避免三角形的边框修补问题，我选择了不绘制三角形，而是绘制一个正方形将其旋转45°，通过设置正方形的两个相邻边框让其拥有“三角形边框”，并且通过定位来实现三角形的遮盖。</p>

<p>整个过程如下。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890747854821.jpg" alt=""/></p>

<p>详细代码如下。</p>

<pre><code class="language-css">.tooltip {
 width: 100px;
 height: 50px;
 border: 1px solid #5a89c7;
 border-radius: 2px;
 box-shadow: 0 0 10px #abcdef;
 padding: 2px;
 box-sizing: border-box;
 position: relative;
 z-index: 9;
 font-size: 12px;
 line-height: 12px;
 text-align: center;
}

.tooltip::after {
 content: &#39;&#39;;
 position: absolute;
 display: block;
 text-align: center;
 width: 30px;
 height: 30px;
 background-color: #fff;
 border: 1px solid #5a89c7;
 border-style: solid;
 border-width: 1px;
 border-width: 0 1px 1px 0;
 bottom: -32px;
 left: 50%;
 transform: translate(-50%, -50%) rotate(45deg);
 z-index: -1; 
}
</code></pre>

<pre><code class="language-html">&lt;div class=&quot;tooltip&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;Hello, tooltip!Hover to see me!&lt;/div&gt;
&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(3)——未完待续]]></title>
    <link href="beace.github.io/css-draw-more.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-more.html</id>
    <content type="html"><![CDATA[
<p>明天我将继续记录以下图形的绘制。有些很简单，有些也很简单。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752802585.jpg" alt=""/></p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752967384.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(4)—— 电源插头]]></title>
    <link href="beace.github.io/css-draw-power-plug.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-power-plug.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>电源插头组合了很多内容，包括三角形，矩形，其实最终形成的图形类似多边形，如下图所示。</p>
</blockquote>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752967384.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">原理与实现</a>
</li>
</ul>


<h2 id="toc_1">原理与实现</h2>

<p>原理很简单，六边形的左下和右下的边是由分别有不同位置的两个三角形堆叠而成，这里会有一些简单的计算，建议直接在浏览器端调试即可。中间类似插孔形状的东西其实只不过是圆角的利用罢了。</p>

<pre><code class="language-html">&lt;div class=&quot;plus-wrapper&quot;&gt;
    &lt;div class=&quot;plus&quot;&gt;
     &lt;div class=&quot;triangle triangle-lb&quot;&gt;&lt;/div&gt;
     &lt;div class=&quot;triangle triangle-rb&quot;&gt;&lt;/div&gt;
     &lt;div class=&quot;plus-port-wrapper plus-port-wrapper-t&quot;&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;div class=&quot;plus-port-wrapper&quot;&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>我会经常通过一些伪类来实现一些<code>css</code>效果，尤其是<code>::after</code>、<code>::before</code>。这样减少了冗余的标签的同时，样式也容易控制。</p>

<p>通过<code>triangle-lb,::before</code>和<code>triangle-rb,::after</code>的堆叠来实现六边形的两条边。</p>

<pre><code class="language-css">.plus-wrapper {
    width: 130px;
    height: 98px;
    border: 1px solid #000;
    padding: 16px;
    box-sizing: border-box;
    position: relative;
  }
  .plus {
    border: 1px solid #000;
    width: 100%;
    height: 100%;
  }
  .plus::before {
    content: &quot;&quot;;
    position: absolute;
    top: 61px;
    left: 17px;
    width: 0;
    height: 0;
    border-left: 0 solid transparent;
    border-right: 24px solid transparent;
    border-bottom: 20px solid #000;
    z-index: 1;
  }
  .plus::after {
    content: &quot;&quot;;
    position: absolute;
    top: 61px;
    right: 15px;
    width: 0;
    height: 0;
    border-left: 24px solid transparent;
    border-right: 0;
    border-bottom: 20px solid #000;
    z-index: 1;
  }
  .triangle {
    position: absolute;
    z-index: 3;
  }
  .triangle-lb {
    top: 61px;
    left: 16px;
    width: 0;
    height: 0;
    border-left: 0 solid transparent;
    border-right: 25px solid transparent;
    border-bottom: 21px solid #fff;
  }
  .triangle-rb {
    top: 61px;
    right: 14px;
    width: 0;
    height: 0;
    border-left: 25px solid transparent;
    border-right: 0;
    border-bottom: 21px solid #fff;
  }
  .plus-port-wrapper {
    width: 100%;
    text-align: center;
  }
  .plus-port-wrapper-t{
    margin-top: 4px
  }
  .plus-port {
    margin: 0 12px 0;
    width: 5px;
    border: 1px solid #000;
    height: 24px;
    display: inline-block;
    border-radius: 10px;
  }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(5)—插头]]></title>
    <link href="beace.github.io/css-draw-plug.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-plug.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这个图形其实很少看到，其实在实际生活中，经常会有这样的插头形状，像主机和显示器的相连接的插头。需要两个螺丝钉去固定，以及几个端口去连接。</p>
</blockquote>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752802585.jpg" alt="img"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">原理</a>
<ul>
<li>
<a href="#toc_2">HTML结构</a>
</li>
<li>
<a href="#toc_3">最外层div的圆角实现</a>
</li>
<li>
<a href="#toc_4">螺丝钉原理</a>
<ul>
<li>
<a href="#toc_5">公共部分</a>
</li>
<li>
<a href="#toc_6">位置信息</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">端口原理</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_1">原理</h2>

<p>最外面的<code>div</code>可以使用圆角的特性，来定义不同位置的圆角显示。</p>

<p>对于两边螺丝钉，我仍然喜欢借助伪类<code>::before</code>和<code>::after</code>来进行螺丝钉的绘制。这两个螺丝钉，大小，形状，内容完全一致。只有位置不统一，因此我们可以先写common部分，然后去分别定义位置信息。</p>

<h3 id="toc_2">HTML结构</h3>

<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;port-wrapper&quot;&gt;
      &lt;div class=&quot;port-dot-wrapper&quot;&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;port-dot-wrapper&quot;&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>

<p>​           </p>

<h3 id="toc_3">最外层div的圆角实现</h3>

<pre><code class="language-css">.container {  
  position: relative;
  width: 80px;
}
.port-wrapper {
  border: 1px solid #000;
  width: 78px;
  height: 36px;
  padding: 4px;
  box-sizing: border-box;
  border-radius: 4px 4px 17px 17px;
}
</code></pre>

<h3 id="toc_4">螺丝钉原理</h3>

<h4 id="toc_5">公共部分</h4>

<p>通过伪类的<code>content</code>来定义内容，通过绝对定位定义其位置信息。</p>

<pre><code class="language-css">.port-wrapper::before,
.port-wrapper::after {
  content: &quot;x&quot;;
  display: block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  text-align: center;
  border: 1px solid #000;
  line-height: 12px;
  font-size: 12px;
  position: absolute;
}
</code></pre>

<h4 id="toc_6">位置信息</h4>

<pre><code class="language-Css">.port-wrapper::before {
  left: -16px;
  top: 0;
}
.port-wrapper::after {
  right: -14px;
  top: 0;
}
</code></pre>

<h3 id="toc_7">端口原理</h3>

<p>端口其实比较简单，只需要定义两行端口居中排开即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[json-server and xmlhttprequest]]></title>
    <link href="beace.github.io/json-server-ajax.html"/>
    <updated>2017-03-13T13:01:48+08:00</updated>
    <id>beace.github.io/json-server-ajax.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前提</h2>

<blockquote>
<p>在很多时候，前端程序员往往较早一步实现页面逻辑，后端程序员由于需要联调、掌握业务逻辑，消耗的时间比较长一点。那前端为了等后端程序员开发完成之后，<em>API</em>能够通过直接修改<em>URL</em>来对接，就需要伪造一些数据，但是，大部分情况而言，伪造的数据都是不变的。前端脚本不可能用来实现对数据的增删该查。但是，昨天意外发现一个工具——<a href="https://github.com/typicode/json-server">json-server</a>,可以帮助前端程序员来解决页面逻辑控制的痛点。下面我通过一个简单的增删改查的例子来进行记录。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_1">目录</h2>

<ul>
<li>
<a href="#toc_0">前提</a>
</li>
<li>
<a href="#toc_1">目录</a>
<ul>
<li>
<a href="#toc_2">知识点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">具体实现</a>
<ul>
<li>
<a href="#toc_4">json-server的安装</a>
</li>
<li>
<a href="#toc_5">json-server的启动</a>
</li>
<li>
<a href="#toc_6">POSTMAN测试</a>
</li>
<li>
<a href="#toc_7">XMLHttpRequest</a>
</li>
</ul>
</li>
</ul>


<h3 id="toc_2">知识点</h3>

<ul>
<li><p><a href="https://github.com/typicode/json-server">json-server</a>的安装和使用</p></li>
<li><p>POSTMAN的简单实用</p></li>
<li><p><em>XMLHttpRequest</em>对象的用法</p></li>
</ul>

<h2 id="toc_3">具体实现</h2>

<h3 id="toc_4"><a href="https://github.com/typicode/json-server">json-server</a>的安装</h3>

<p>可以直接去<em>github</em>中查询其<em>API</em>。通过<em>npm</em>安装在全局中：</p>

<pre><code class="language-sh">$ npm install -g json-server
</code></pre>

<h3 id="toc_5"><a href="https://github.com/typicode/json-server">json-server</a>的启动</h3>

<p>在启动之前，先来伪造一些数据。新建一个<em>json</em>文件，命名为<em>/db.json</em>,添加以下数据：</p>

<pre><code>{
  &quot;getArticle&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;title&quot;: &quot;json-1&quot;,
      &quot;content&quot;: &quot;beace2&quot;
    },
    {
      &quot;id&quot;: 3,
      &quot;title&quot;: &quot;json-2&quot;,
      &quot;content&quot;: &quot;beace3&quot;
    }
  ],
  &quot;postArticle&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;title&quot;: &quot;json-server&quot;,
      &quot;content&quot;: &quot;typicode&quot;
    }
  ]
}
</code></pre>

<p>在命令行中，键入:</p>

<pre><code class="language-sh">$ json-server /path/to/db.json
</code></pre>

<p>可以观察到，服务启动在了本地的<em>3000</em>端口，截图如下：</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-start.png" alt="img"/></p>

<p>我们可以访问<a href="http://localhost:3000/getArticle">http://localhost:3000/getArticle</a>,来看到服务返回的<em>json</em>信息。(当然，可也以访问<a href="http://localhost:3000/postArticle">http://localhost:3000/postArticle</a>，总之既定规则由你来决定)</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-get.png" alt="json-server-return"/></p>

<h3 id="toc_6">POSTMAN测试</h3>

<p>其实，这样的功能并不能够证明其有多么遍历，我们随便伪造一个<em>json</em>文件也可以通过这样请求来获取数据，其实便利在于我们可以改变数据，而且是真实发生。</p>

<p>可以通过POSTMAN来进行测试,效果如下诸多截图。</p>

<p>获取数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman.png" alt="img"/></p>

<p>通过<em>id</em>获取数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-delete.png" alt="img"/></p>

<p><em>POST</em>数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-post.png" alt="img"/></p>

<p><em>DELETE</em>数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-delete.png" alt="img"/></p>

<p>一系列操作之后 ，回到<em>/db.json</em>中会发现数据发生了改变。</p>

<h3 id="toc_7">XMLHttpRequest</h3>

<p>通过一个简单的请求来获取数据并展示在网页上：</p>

<pre><code class="language-js">getJSON(&#39;http://localhost:3000/getArticle&#39;, function(response) {
    console.log(response);
})
function getJSON(url, callback) {
    var request = new XMLHttpRequest();
    request.open(&#39;GET&#39;, url);
    request.onreadystatechange = function () {
    //为了排版优美，省略了状态判断
        if (callback) {
            callback(JSON.parse(request.responseText));
        }
    };
    request.send(null);
}

</code></pre>

<p><em>XMLHttpRequest</em>的使用必须通过<em>http</em>协议，在这里介绍一个轻量级的<em>web server</em>——<em>http-server</em>.</p>

<p>通过npm全局安装：</p>

<pre><code class="language-sh">$ npm install -g http-server
</code></pre>

<p>在项目根目录中运行：</p>

<pre><code class="language-sh">$ http-server
</code></pre>

<p>打开浏览器，进入<a href="http://localhost:8080">http://localhost:8080</a>.</p>

]]></content>
  </entry>
  
</feed>
