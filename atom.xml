<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[beace lee的博客]]></title>
  <link href="beace.github.io/atom.xml" rel="self"/>
  <link href="beace.github.io/"/>
  <updated>2017-04-14T20:34:53+08:00</updated>
  <id>beace.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Arguments]]></title>
    <link href="beace.github.io/JavaScript-arguments.html"/>
    <updated>2017-03-24T17:26:49+08:00</updated>
    <id>beace.github.io/JavaScript-arguments.html</id>
    <content type="html"><![CDATA[
<p>上一次说到了JavaScript中加引号和不加引号的区别，已经认知到了在大体上还是没有区别的。这里我将深入的了解JavaScript函数中的arguments对象，将其运用到实战。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">正文</a>
</li>
<li>
<a href="#toc_2">Arguments</a>
<ul>
<li>
<a href="#toc_3">arguments中的参数</a>
<ul>
<li>
<a href="#toc_4">特点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">arguments中的arguments.callee属性</a>
</li>
<li>
<a href="#toc_6">arguments个数</a>
</li>
<li>
<a href="#toc_7">arguments@@iterator</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">arguments(object) to array</a>
</li>
</ul>


<h2 id="toc_1">正文</h2>

<p>首先，回顾一下上一次的代码。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments[0])
  console.log(arguments[1])
  console.log(arguments[&#39;0&#39;])
  console.log(arguments[&#39;1&#39;])
}

getArgs(1, 2);

var b = {&quot;b&quot;: &quot;b&quot;};
var b2 = {b: &quot;b&quot;};
console.log(b.b);
console.log(JSON.stringify(b))
console.log(JSON.stringify(b2))
</code></pre>

<p>在这里，我们可以看到其实访问都没有错误。都会返回我们想要的结果。唯一的区别是有引号和没有引号的区别。我们知道JavaScript中表示字符串的时候双引号和单引号是没有区别的（字符串拼接除外），编译器都可以识别。例如上述代码运行时不会出错的。</p>

<p>但是，如果我们想获取getArgs()中参数的个数，可以写成这样吗？</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments.length)
}
</code></pre>

<p>答案是肯定的。但arguments仍然不是一个数组，它是一个只具备length属性的对象。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(typeof arguments); // object
}
</code></pre>

<p>可以看出，arguments是object类型的，只有array类型才具有length属性。那为何可以像数组那样访问呢？ </p>

<p>在这里，先打住。我们来看下array是如何获取元素的。</p>

<pre><code class="language-js">const arr = [1,2,3,4];
for (let i = 0; i &lt; arr.length; i ++) {
  console.log(a[i]); //1 2 3 4
}
</code></pre>

<p>上述代码迭代了arr数组，并且我们通过Array[index]的方式进行数组元素的获取。试想一下，如果给index加上引号呢？还能如期获取吗？</p>

<pre><code class="language-js">//将 console.log(a[i]) 替换
console.log(a[i.toString()]) //1 2 3 4
</code></pre>

<p>可以看到，数组如约输出。不信你可以尝试<code>a[&#39;0&#39;]</code>的方式去访问，依然可以获得元素。</p>

<p><em>这是为什么呢？</em></p>

<p>首先，我们来查看下Array在JavaScript中定义的类型。</p>

<pre><code class="language-js">typeof Array //object
</code></pre>

<p>可以看到，Array是object类型。尽管我们没有必要这样加引号的去访问，但是事实上是可以这样的。因为a[0]中的整型0被JavaScript强制地隐式转换（toString()）为字符串&#39;0&#39;。如果你不相信，Mozilla MDN上有一个非常好的例子来说明这一点 （<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array%EF%BC%89">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array）</a> 。比如：</p>

<p>我们声明一个数组，并且像如下访问。</p>

<pre><code class="language-js">var arr = [1,2,3,4,5];
console.log(arr[01] === arr[1]); // true
//这里 arr[&#39;01&#39;] === undefined
console.log(arr[&#39;01&#39;] === arr[&#39;1&#39;]) // false
</code></pre>

<p>我们知道，在整数的高位补0，十进制里还等于其本身。</p>

<pre><code class="language-js">01 === 1 // true
</code></pre>

<p>而数字作为字符串比较，当然就不同。</p>

<pre><code class="language-js">&#39;01&#39; === &#39;1&#39; //false
</code></pre>

<blockquote>
<p>The 2 in years[2] is coerced into a string by the JavaScript engine through an implicit toString conversion. It is for this reason that &#39;2&#39; and &#39;02&#39; would refer to two different slots on the years object and the following example could be true. —— <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">by Mozilla MDN JavaScript Array</a></p>
</blockquote>

<p>这下你应当知道，原来JavaScript也是通过”强制补引号“的方式进行数组索引的处理。那就不难理解为何arguments也可以这样了。容易进入误区的是arguments[0]这样的访问方式容易让人觉得他就是个数组。对于引号没有研究透彻的JavaScript开发者来说，是很大一个误区。</p>

<h2 id="toc_2">Arguments</h2>

<p>现在正式进入arguments的正题。话说既然arguments是个对象，那它里面有什么呢？</p>

<p><img src="media/14903476099970/14903511503835.jpg" alt=""/></p>

<p>这里打印了showMeArgs(1, 2)中的arguments对象。有如下属性</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>function中的第一个参数</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>function中的第二个参数</td>
</tr>
<tr>
<td>callee</td>
<td>showMeArgs(a, b)</td>
<td>当前执行的函数</td>
</tr>
<tr>
<td>length</td>
<td>2</td>
<td>内置属性，获取参数个数</td>
</tr>
<tr>
<td>iterator</td>
<td>array</td>
<td>返回一个新的Array Iterator对象，该对象包含参数中每个索引的值</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">arguments中的参数</h3>

<p>上面图表中的<code>0,1</code>，即对应形参的<code>a,b</code>。</p>

<h4 id="toc_4">特点</h4>

<ul>
<li>可以通过arguments[0]的方式获取或设置属性，设置属性时，会覆盖实参</li>
</ul>

<pre><code class="language-js">function showMeArgs(a, b) {
  arguments[0] = 10;
  console.log(arguments[0]); //10
  console.log(a + b);
}

showMeArgs(1, 2); //12
</code></pre>

<ul>
<li>当默认参数提供时，实参不会被覆盖</li>
</ul>

<pre><code class="language-js">function showMeArgs(a = 1, b) {
  arguments[0] = 100;
  console.log(a + b);
}
showMeArgs(10, 3) // 13
</code></pre>

<ul>
<li>ES6 当使用省略参数（rest parameters）的写法时，arugments也可以返回</li>
</ul>

<pre><code class="language-js">function showMeArgs(...args) {
  console.log(arguments);
}
showMeArgs(1, 2, 3); // object
</code></pre>

<h3 id="toc_5">arguments中的arguments.callee属性</h3>

<p>包含当前执行的功能。这句话可能有些别扭。通俗一点来说，它可以指代该函数函数体内当前执行的函数。</p>

<p>语言描述可能不太准确，在这里可以看一个例子。</p>

<p>如果有一个数组，这个数组我希望能够求出每个元素从<em>0加到该元素的和</em>并返回。可以这样来实现。</p>

<ul>
<li>先把求和这个动作抽象出来。</li>
</ul>

<pre><code class="language-js">function plus(n) {
  return n === 0 ? 0 : plus(n - 1) + n;
}
</code></pre>

<ul>
<li>接着迭代数组加求和</li>
</ul>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(n =&gt; plus(n)) //[0, 1, 3, 6, 10, 15, 21]
</code></pre>

<p>可以看到，我们通过调用plus()实现了。如果我们觉得业务逻辑比较简单，为了代码简洁，想要把抽象出来的东西放在map方法中。</p>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(n =&gt; n === 0 ? 0 : (n - 1) + n); // [0, 1, 3, 5, 7, 9, 11]
</code></pre>

<p>可以看到并没有按照想要的结果去求和，反而直接计算了。这时我们可以使用callee方法代表一个匿名函数来解决这一问题。</p>

<pre><code class="language-js">[0,1,2,3,4,5,6].map(function(n){
  return n === 0 ? 0 : arguments.callee(n - 1) + n
});
</code></pre>

<p>这个时候，我们就不能够使用ES6箭头函数的新特性了。因为arguments为undefined。</p>

<pre><code class="language-sh">Uncaught ReferenceError: arguments is not defined
</code></pre>

<p>相比之下，其实这种递归调动以及内联函数的写法很不友好。我们无法抽象出想要的方法，并且无法进行进一步的优化。在高阶函数中，经常很多函数作为另一个函数的参数进行传递，这样的写法难以维护。如果大量使用，甚至可能造成性能上的问题，例如不可避免的嵌套的匿名回调函数（callback function）等。将来的可能被废弃掉。</p>

<h3 id="toc_6">arguments个数</h3>

<p>通过arguments.length可以获取函数中参数的个数。<strong>但其不是数组</strong></p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments.length) //2
}
</code></pre>

<h3 id="toc_7">arguments<a href="">@@iterator</a></h3>

<p>Array的迭代器。类似Array.prototype.value的使用，现在除Firefox Nightly版本能够体验外，各大浏览器均不支持。例如：</p>

<pre><code class="language-js">var arr = [&#39;w&#39;, &#39;y&#39;, &#39;k&#39;, &#39;o&#39;, &#39;p&#39;];
var iterator = arr.values();
for (let letter of iterator) {
  console.log(letter);
}
</code></pre>

<h2 id="toc_8">arguments(object) to array</h2>

<p>通过上面的所有表述，我们已经知道arguments已经是一个object类型。那可以通过一定方式将arguments的类型转换为array吗？</p>

<p>可能似乎没有这样的需求。我来介绍一个例子。</p>

<blockquote>
<p>以下灵感来自 <a href="https://t.75team.com/video/">https://t.75team.com/video/</a> JavaScript视频</p>
</blockquote>

<p>比如，你的一个同事或者合作的伙伴写了一个改变元素颜色的函数，如下。</p>

<pre><code class="language-js">function setColor(color, ele) {
  ele.style.color = color;
}
</code></pre>

<p>这个函数看起来没有什么特别，唯一让人看起来别扭的可能是参数的位置。我们可能习惯第一个形参为元素（ele），第二个形参为颜色（color），因此我们可以实现一个方法将参数内容转置， 这里就用到了arguments。</p>

<pre><code class="language-js">function setColorReverse(fn) {
  return function(color, ele) {
    var args = Array.prototype.slice.call(arguments);
    fn.apply(this, args.reverse());
  }
}
setColorReverse(setColor(&#39;container&#39;, &#39;blue&#39;));
</code></pre>

<p>同样，除了像Array.prototype.slice.call(arguments)这样的处理之外，还可以替换为：</p>

<pre><code class="language-js">[].slice.call(arguments) || Array.from(arguments)
</code></pre>

<p>在ES6中，这样写更简单。</p>

<pre><code class="language-js">function reverseArgs(fn) {
  return function(...args) {
    fn.apply(null, [...args].reverse());
  }
}

reverseArgs(setColor)(content, &#39;blue&#39;);  // so the color of content is blue
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript一些有趣的地方]]></title>
    <link href="beace.github.io/javascript-object-funny.html"/>
    <updated>2017-03-16T11:49:34+08:00</updated>
    <id>beace.github.io/javascript-object-funny.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Array-like</h2>

<p>所谓的Array-like,即类数组。其实并不是数组，但是可以像数组一样的进行访问，在这里，仅仅是写法上的一致。其实并不是数组。</p>

<h2 id="toc_1">对象(<em>Object</em>)</h2>

<ul>
<li>对象不加引号和加引号的区别，可以参考该链接（<a href="http://stackoverflow.com/questions/4348478/what-is-the-difference-between-object-keys-with-quotes-and-without-quotes%EF%BC%89">http://stackoverflow.com/questions/4348478/what-is-the-difference-between-object-keys-with-quotes-and-without-quotes）</a></li>
</ul>

<pre><code class="language-js">var a = {a: &quot;a&quot;};
var b = {&quot;b&quot;: &quot;b&quot;};
console.log(a); //&quot;a&quot;
console.log(b); //&quot;b&quot;
</code></pre>

<ul>
<li>特殊情况不可以用<em>点</em>的属性访问</li>
</ul>

<pre><code class="language-js">var a = {0: &quot;a&quot;}; 
console.log(a.0); //Uncaught SyntaxError: Unexpected number
//竟然可以像一个数组进行访问
console.log(a[0]); // &quot;a&quot;
//为了以便区分，可以加上引号
console.log(a[&#39;0&#39;]) // &quot;a&quot;
</code></pre>

<blockquote>
<p>No, the quotes do not make a difference (unless, as you noted, you want to use a key that’s not a valid JavaScript identifier).</p>
</blockquote>

<p>可见，如果符合规范的定义<code>key</code>值，加引号和不加引号是没有区别的。如果你的<code>key</code>值中出现数字或者<code>JavaScript</code>中的关键字，可以通过加引号的方式访问<code>obj[&#39;key&#39;]</code></p>

<h2 id="toc_2">引申</h2>

<p>说到这里，我想引申一个东西，跟上面的对象理解（类数组）完全一致。就是<em>JavaScript</em>函数中的<em>arguments</em>参数。</p>

<p><em>arguments</em>对象是所有<em>JavaScript</em>函数中的局部变量。通过<em>arguments</em>我们可以获取函数中的所有参数。</p>

<pre><code class="language-js">function getArgs(a, b) {
  console.log(arguments[0])
  console.log(arguments[1])  
}

getArgs(1, 2); // 1 2
</code></pre>

<p>通过上述代码，我们可以通过类似数组的方式进行参数的读取，判断等等。接下来的一篇文章将会探索<em>arguments</em>的真正类型以及含义。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(1)——矩形]]></title>
    <link href="beace.github.io/css-draw-rectangle.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-rectangle.html</id>
    <content type="html"><![CDATA[
<p>首先在这里声明，对于<code>css</code>画图来说，大部分的图案的宽度甚至高度都是固定的，就算采用百分比的方式来绘制，也会有最外面的边界限制。尽量在PC端或者响应式要求不太高的场景下进行，当然会有一些比较简单的图案绘制能够适应响应式的方式，可以采用canvas或svg来绘制。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">矩形的堆叠</a>
</li>
<li>
<a href="#toc_2">凹凸形(矩形)</a>
</li>
</ul>


<h2 id="toc_1">矩形的堆叠</h2>

<p>如下图形，可以用来表示服务器。是最简单的一种图形绘制，不需要太多技巧。简单的div嵌套即可完成。为一个注意的地方就是里面的图形，可以用百分比来绘制，这样改变外层div的同时，里面也会相应变化。在这里就省略代码了。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890753662725.jpg" alt=""/></p>

<h2 id="toc_2">凹凸形(矩形)</h2>

<p>其实这种图形（如下图）比较少见，但是常常用来描述端口。原理是几个矩形的堆叠，通过相对定位/绝对定位之后的top属性来固定位置，z-index属性来遮掩上下边框。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890709420668.jpg" alt=""/></p>

<p>你可以设置每个矩形的宽度为百分比，但是最终会于设计图相差甚远。而且，还要去考虑绝对定位元素居中的问题，当然这不是很困难。但是如果你的场景没有那么复杂，你可以像我这样来写。</p>

<p>先固定最外面盒子的宽高，然后通过top的属性值来决定元素的上下堆叠位置，left为居中设置。border设置边框的有无，z-index属性决定元素垂直屏幕的层级关系。从下往上，逐层的z-index逐渐变大。</p>

<pre><code class="language-css">.switch-wrapper{
  width: 54px;
  position: relative;
  height: 30px;  
}
.switch{
  border: 2px solid #000;
  margin: 0 auto;
  position: absolute;
  background-color: #fff;
}
.switch-1,
.switch-2 {
  border-bottom: 0;
}
.switch-1{
  width: 14px;
  height: 4px;
  z-index: 3;
  left: 18px;
}
.switch-2 {
  width: 30px;
  height: 6px;
  z-index: 2;
  top: 4px;
  left: 10px;
}
.switch-3 {
  width: 50px;
  height: 16px;
  font-size: 12px;
  text-align: center;
  line-height: 15px;
  z-index: 1;
  bottom: 0;
}
</code></pre>

<pre><code class="language-html">&lt;div className=&quot;switch-wrapper&quot;&gt;
    &lt;div className=&quot;switch switch-1&quot;&gt;&lt;/div&gt;
    &lt;div className=&quot;switch switch-2&quot;&gt;&lt;/div&gt;
    &lt;div className=&quot;switch switch-3&quot;&gt;G0/1&lt;/div&gt;
&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(2)——三角形]]></title>
    <link href="beace.github.io/css-draw-triangle.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-triangle.html</id>
    <content type="html"><![CDATA[
<p>三角形相对来说比较简单，我们可以通过设置border属性轻易实现。我来实现一个简单的和一个有难度的。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">三角形（简单）</a>
<ul>
<li>
<a href="#toc_2">留下一个思考题。</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">三角形（复杂）</a>
</li>
</ul>


<h2 id="toc_1">三角形（简单）</h2>

<p>通过设置三角形（如下图）的四个边的不同颜色，来实现三角形的绘制。其中，包括直角三角形、等边三角形等特殊三角形。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890722556585.jpg" alt=""/></p>

<p>其实从严格意义上来说这不是一个三角形(如下图)，只不过我们看到的是一个三角形的形状。它的形成过程是这样的。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890732104056.jpg" alt=""/></p>

<p>如下图所示，它并非只占有一个三角形的区域，而是一个正方形div盒子。类似一张三角形的png图片，右上方是透明的。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890723173742.jpg" alt=""/></p>

<p>下面展示了一个直角三角形的实现方式。</p>

<pre><code class="language-css">.triangle {
    width: 0;
    height: 0;
    border-right: 50px solid transparent;
    border-bottom: 50px solid #abcdef;
}
</code></pre>

<pre><code class="language-html">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;
</code></pre>

<h3 id="toc_2">留下一个思考题。</h3>

<p>回顾一个三角形的变化那张图，细心的可以发现，边框所设置的宽度，与div盒子占有的宽高好像不太一致。如下图，我设置了每个方向的 border 都为100px,为何占有的宽度为99.2呢？</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890735852383.jpg" alt=""/></p>

<h2 id="toc_3">三角形（复杂）</h2>

<p>我们来实现一个比较常用的tooltip效果。做这样的一个效果（如下图）有很多方法。比如通过三角形的堆叠差异，来实现三角形的两条线。或者先绘制一个三角形，然后将两个线定位到三角形的边上。其实都不优雅，因为我们知道通过border来绘制三角形只能填充其border-color，没有办法描边。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890739284055.jpg" alt=""/></p>

<p>在这里，我采用一种比较独特的方法。为了避免三角形的边框修补问题，我选择了不绘制三角形，而是绘制一个正方形将其旋转45°，通过设置正方形的两个相邻边框让其拥有“三角形边框”，并且通过定位来实现三角形的遮盖。</p>

<p>整个过程如下。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890747854821.jpg" alt=""/></p>

<p>详细代码如下。</p>

<pre><code class="language-css">.tooltip {
 width: 100px;
 height: 50px;
 border: 1px solid #5a89c7;
 border-radius: 2px;
 box-shadow: 0 0 10px #abcdef;
 padding: 2px;
 box-sizing: border-box;
 position: relative;
 z-index: 9;
 font-size: 12px;
 line-height: 12px;
 text-align: center;
}

.tooltip::after {
 content: &#39;&#39;;
 position: absolute;
 display: block;
 text-align: center;
 width: 30px;
 height: 30px;
 background-color: #fff;
 border: 1px solid #5a89c7;
 border-style: solid;
 border-width: 1px;
 border-width: 0 1px 1px 0;
 bottom: -32px;
 left: 50%;
 transform: translate(-50%, -50%) rotate(45deg);
 z-index: -1; 
}
</code></pre>

<pre><code class="language-html">&lt;div class=&quot;tooltip&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;Hello, tooltip!Hover to see me!&lt;/div&gt;
&lt;/div&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(3)——未完待续]]></title>
    <link href="beace.github.io/css-draw-more.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-more.html</id>
    <content type="html"><![CDATA[
<p>明天我将继续记录以下图形的绘制。有些很简单，有些也很简单。</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752802585.jpg" alt=""/></p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752967384.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(4)—— 电源插头]]></title>
    <link href="beace.github.io/css-draw-power-plug.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-power-plug.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>电源插头组合了很多内容，包括三角形，矩形，其实最终形成的图形类似多边形，如下图所示。</p>
</blockquote>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752967384.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">原理与实现</a>
</li>
</ul>


<h2 id="toc_1">原理与实现</h2>

<p>原理很简单，六边形的左下和右下的边是由分别有不同位置的两个三角形堆叠而成，这里会有一些简单的计算，建议直接在浏览器端调试即可。中间类似插孔形状的东西其实只不过是圆角的利用罢了。</p>

<pre><code class="language-html">&lt;div class=&quot;plus-wrapper&quot;&gt;
    &lt;div class=&quot;plus&quot;&gt;
     &lt;div class=&quot;triangle triangle-lb&quot;&gt;&lt;/div&gt;
     &lt;div class=&quot;triangle triangle-rb&quot;&gt;&lt;/div&gt;
     &lt;div class=&quot;plus-port-wrapper plus-port-wrapper-t&quot;&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;div class=&quot;plus-port-wrapper&quot;&gt;
       &lt;div class=&quot;plus-port&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>我会经常通过一些伪类来实现一些<code>css</code>效果，尤其是<code>::after</code>、<code>::before</code>。这样减少了冗余的标签的同时，样式也容易控制。</p>

<p>通过<code>triangle-lb,::before</code>和<code>triangle-rb,::after</code>的堆叠来实现六边形的两条边。</p>

<pre><code class="language-css">.plus-wrapper {
    width: 130px;
    height: 98px;
    border: 1px solid #000;
    padding: 16px;
    box-sizing: border-box;
    position: relative;
  }
  .plus {
    border: 1px solid #000;
    width: 100%;
    height: 100%;
  }
  .plus::before {
    content: &quot;&quot;;
    position: absolute;
    top: 61px;
    left: 17px;
    width: 0;
    height: 0;
    border-left: 0 solid transparent;
    border-right: 24px solid transparent;
    border-bottom: 20px solid #000;
    z-index: 1;
  }
  .plus::after {
    content: &quot;&quot;;
    position: absolute;
    top: 61px;
    right: 15px;
    width: 0;
    height: 0;
    border-left: 24px solid transparent;
    border-right: 0;
    border-bottom: 20px solid #000;
    z-index: 1;
  }
  .triangle {
    position: absolute;
    z-index: 3;
  }
  .triangle-lb {
    top: 61px;
    left: 16px;
    width: 0;
    height: 0;
    border-left: 0 solid transparent;
    border-right: 25px solid transparent;
    border-bottom: 21px solid #fff;
  }
  .triangle-rb {
    top: 61px;
    right: 14px;
    width: 0;
    height: 0;
    border-left: 25px solid transparent;
    border-right: 0;
    border-bottom: 21px solid #fff;
  }
  .plus-port-wrapper {
    width: 100%;
    text-align: center;
  }
  .plus-port-wrapper-t{
    margin-top: 4px
  }
  .plus-port {
    margin: 0 12px 0;
    width: 5px;
    border: 1px solid #000;
    height: 24px;
    display: inline-block;
    border-radius: 10px;
  }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享一些CSS画图技巧(5)—插头]]></title>
    <link href="beace.github.io/css-draw-plug.html"/>
    <updated>2017-03-15T10:14:17+08:00</updated>
    <id>beace.github.io/css-draw-plug.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>这个图形其实很少看到，其实在实际生活中，经常会有这样的插头形状，像主机和显示器的相连接的插头。需要两个螺丝钉去固定，以及几个端口去连接。</p>
</blockquote>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/Css-draw/14890752802585.jpg" alt="img"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">原理</a>
<ul>
<li>
<a href="#toc_2">HTML结构</a>
</li>
<li>
<a href="#toc_3">最外层div的圆角实现</a>
</li>
<li>
<a href="#toc_4">螺丝钉原理</a>
<ul>
<li>
<a href="#toc_5">公共部分</a>
</li>
<li>
<a href="#toc_6">位置信息</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">端口原理</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_1">原理</h2>

<p>最外面的<code>div</code>可以使用圆角的特性，来定义不同位置的圆角显示。</p>

<p>对于两边螺丝钉，我仍然喜欢借助伪类<code>::before</code>和<code>::after</code>来进行螺丝钉的绘制。这两个螺丝钉，大小，形状，内容完全一致。只有位置不统一，因此我们可以先写common部分，然后去分别定义位置信息。</p>

<h3 id="toc_2">HTML结构</h3>

<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;port-wrapper&quot;&gt;
      &lt;div class=&quot;port-dot-wrapper&quot;&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;port-dot-wrapper&quot;&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;port-dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>

<p>​           </p>

<h3 id="toc_3">最外层div的圆角实现</h3>

<pre><code class="language-css">.container {  
  position: relative;
  width: 80px;
}
.port-wrapper {
  border: 1px solid #000;
  width: 78px;
  height: 36px;
  padding: 4px;
  box-sizing: border-box;
  border-radius: 4px 4px 17px 17px;
}
</code></pre>

<h3 id="toc_4">螺丝钉原理</h3>

<h4 id="toc_5">公共部分</h4>

<p>通过伪类的<code>content</code>来定义内容，通过绝对定位定义其位置信息。</p>

<pre><code class="language-css">.port-wrapper::before,
.port-wrapper::after {
  content: &quot;x&quot;;
  display: block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  text-align: center;
  border: 1px solid #000;
  line-height: 12px;
  font-size: 12px;
  position: absolute;
}
</code></pre>

<h4 id="toc_6">位置信息</h4>

<pre><code class="language-Css">.port-wrapper::before {
  left: -16px;
  top: 0;
}
.port-wrapper::after {
  right: -14px;
  top: 0;
}
</code></pre>

<h3 id="toc_7">端口原理</h3>

<p>端口其实比较简单，只需要定义两行端口居中排开即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[json-server and xmlhttprequest]]></title>
    <link href="beace.github.io/json-server-ajax.html"/>
    <updated>2017-03-13T13:01:48+08:00</updated>
    <id>beace.github.io/json-server-ajax.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前提</h2>

<blockquote>
<p>在很多时候，前端程序员往往较早一步实现页面逻辑，后端程序员由于需要联调、掌握业务逻辑，消耗的时间比较长一点。那前端为了等后端程序员开发完成之后，<em>API</em>能够通过直接修改<em>URL</em>来对接，就需要伪造一些数据，但是，大部分情况而言，伪造的数据都是不变的。前端脚本不可能用来实现对数据的增删该查。但是，昨天意外发现一个工具——<a href="https://github.com/typicode/json-server">json-server</a>,可以帮助前端程序员来解决页面逻辑控制的痛点。下面我通过一个简单的增删改查的例子来进行记录。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_1">目录</h2>

<ul>
<li>
<a href="#toc_0">前提</a>
</li>
<li>
<a href="#toc_1">目录</a>
<ul>
<li>
<a href="#toc_2">知识点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">具体实现</a>
<ul>
<li>
<a href="#toc_4">json-server的安装</a>
</li>
<li>
<a href="#toc_5">json-server的启动</a>
</li>
<li>
<a href="#toc_6">POSTMAN测试</a>
</li>
<li>
<a href="#toc_7">XMLHttpRequest</a>
</li>
</ul>
</li>
</ul>


<h3 id="toc_2">知识点</h3>

<ul>
<li><p><a href="https://github.com/typicode/json-server">json-server</a>的安装和使用</p></li>
<li><p>POSTMAN的简单实用</p></li>
<li><p><em>XMLHttpRequest</em>对象的用法</p></li>
</ul>

<h2 id="toc_3">具体实现</h2>

<h3 id="toc_4"><a href="https://github.com/typicode/json-server">json-server</a>的安装</h3>

<p>可以直接去<em>github</em>中查询其<em>API</em>。通过<em>npm</em>安装在全局中：</p>

<pre><code class="language-sh">$ npm install -g json-server
</code></pre>

<h3 id="toc_5"><a href="https://github.com/typicode/json-server">json-server</a>的启动</h3>

<p>在启动之前，先来伪造一些数据。新建一个<em>json</em>文件，命名为<em>/db.json</em>,添加以下数据：</p>

<pre><code>{
  &quot;getArticle&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;title&quot;: &quot;json-1&quot;,
      &quot;content&quot;: &quot;beace2&quot;
    },
    {
      &quot;id&quot;: 3,
      &quot;title&quot;: &quot;json-2&quot;,
      &quot;content&quot;: &quot;beace3&quot;
    }
  ],
  &quot;postArticle&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;title&quot;: &quot;json-server&quot;,
      &quot;content&quot;: &quot;typicode&quot;
    }
  ]
}
</code></pre>

<p>在命令行中，键入:</p>

<pre><code class="language-sh">$ json-server /path/to/db.json
</code></pre>

<p>可以观察到，服务启动在了本地的<em>3000</em>端口，截图如下：</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-start.png" alt="img"/></p>

<p>我们可以访问<a href="http://localhost:3000/getArticle">http://localhost:3000/getArticle</a>,来看到服务返回的<em>json</em>信息。(当然，可也以访问<a href="http://localhost:3000/postArticle">http://localhost:3000/postArticle</a>，总之既定规则由你来决定)</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-get.png" alt="json-server-return"/></p>

<h3 id="toc_6">POSTMAN测试</h3>

<p>其实，这样的功能并不能够证明其有多么遍历，我们随便伪造一个<em>json</em>文件也可以通过这样请求来获取数据，其实便利在于我们可以改变数据，而且是真实发生。</p>

<p>可以通过POSTMAN来进行测试,效果如下诸多截图。</p>

<p>获取数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman.png" alt="img"/></p>

<p>通过<em>id</em>获取数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-delete.png" alt="img"/></p>

<p><em>POST</em>数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-post.png" alt="img"/></p>

<p><em>DELETE</em>数据</p>

<p><img src="https://images-manager.oss-cn-shanghai.aliyuncs.com/static/json-server/json-server-postman-delete.png" alt="img"/></p>

<p>一系列操作之后 ，回到<em>/db.json</em>中会发现数据发生了改变。</p>

<h3 id="toc_7">XMLHttpRequest</h3>

<p>通过一个简单的请求来获取数据并展示在网页上：</p>

<pre><code class="language-js">getJSON(&#39;http://localhost:3000/getArticle&#39;, function(response) {
    console.log(response);
})
function getJSON(url, callback) {
    var request = new XMLHttpRequest();
    request.open(&#39;GET&#39;, url);
    request.onreadystatechange = function () {
    //为了排版优美，省略了状态判断
        if (callback) {
            callback(JSON.parse(request.responseText));
        }
    };
    request.send(null);
}

</code></pre>

<p><em>XMLHttpRequest</em>的使用必须通过<em>http</em>协议，在这里介绍一个轻量级的<em>web server</em>——<em>http-server</em>.</p>

<p>通过npm全局安装：</p>

<pre><code class="language-sh">$ npm install -g http-server
</code></pre>

<p>在项目根目录中运行：</p>

<pre><code class="language-sh">$ http-server
</code></pre>

<p>打开浏览器，进入<a href="http://localhost:8080">http://localhost:8080</a>.</p>

]]></content>
  </entry>
  
</feed>
